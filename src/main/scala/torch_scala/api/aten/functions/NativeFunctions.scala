
package torch_scala.api.aten.functions

import java.nio.LongBuffer
import org.bytedeco.javacpp._
import org.bytedeco.javacpp.annotation._
import annotations._
import torch_scala.api.aten._
import torch_scala.api.std._
import torch_scala.{NativeLoader, Torch}
import scala.reflect.ClassTag

@Platform(include = Array( "ATen/Functions.h", "adapters/OptionalAdapter.h", "adapters/StdArrayAdapter.h" ))
@NoOffset object NativeFunctions {
     
	@native @Namespace("at") @ByVal def _cast_Byte[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) non_blocking: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _cast_Byte[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _cast_Char[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) non_blocking: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _cast_Char[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _cast_Double[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) non_blocking: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _cast_Double[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _cast_Float[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) non_blocking: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _cast_Float[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _cast_Int[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) non_blocking: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _cast_Int[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _cast_Long[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) non_blocking: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _cast_Long[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _cast_Short[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) non_blocking: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _cast_Short[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _cast_Half[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) non_blocking: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _cast_Half[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _cudnn_ctc_loss[T, TT <: TensorType](@Const @ByRef log_probs: Tensor[T, TT], @Const @ByRef targets: Tensor[T, TT], @ByVal input_lengths: IntArrayRef, @ByVal target_lengths: IntArrayRef, @Cast(Array("int64_t")) blank: CLongPointer, @Cast(Array("bool")) deterministic: Boolean, @Cast(Array("bool")) zero_infinity: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def _cudnn_rnn_flatten_weight[T, TT <: TensorType](@ByVal weight_arr: TensorList[T, TT], @Cast(Array("int64_t")) weight_stride0: CLongPointer, @Cast(Array("int64_t")) input_size: CLongPointer, @Cast(Array("int64_t")) mode: CLongPointer, @Cast(Array("int64_t")) hidden_size: CLongPointer, @Cast(Array("int64_t")) num_layers: CLongPointer, @Cast(Array("bool")) batch_first: Boolean, @Cast(Array("bool")) bidirectional: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _cudnn_rnn[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @ByVal weight: TensorList[T, TT], @Cast(Array("int64_t")) weight_stride0: CLongPointer, @Const @ByRef weight_buf: Tensor[T, TT], @Const @ByRef hx: Tensor[T, TT], @Const @ByRef cx: Tensor[T, TT], @Cast(Array("int64_t")) mode: CLongPointer, @Cast(Array("int64_t")) hidden_size: CLongPointer, @Cast(Array("int64_t")) num_layers: CLongPointer, @Cast(Array("bool")) batch_first: Boolean, dropout: Double, @Cast(Array("bool")) train: Boolean, @Cast(Array("bool")) bidirectional: Boolean, @ByVal batch_sizes: IntArrayRef, @Const @ByRef dropout_state: Tensor[T, TT]): TensorTuple5[T,TT]
	@native @Namespace("at") @ByVal def _cudnn_rnn_backward[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @ByVal weight: TensorList[T, TT], @Cast(Array("int64_t")) weight_stride0: CLongPointer, @Const @ByRef weight_buf: Tensor[T, TT], @Const @ByRef hx: Tensor[T, TT], @Const @ByRef cx: Tensor[T, TT], @Const @ByRef output: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef grad_hy: Tensor[T, TT], @Const @ByRef grad_cy: Tensor[T, TT], @Cast(Array("int64_t")) mode: CLongPointer, @Cast(Array("int64_t")) hidden_size: CLongPointer, @Cast(Array("int64_t")) num_layers: CLongPointer, @Cast(Array("bool")) batch_first: Boolean, dropout: Double, @Cast(Array("bool")) train: Boolean, @Cast(Array("bool")) bidirectional: Boolean, @ByVal batch_sizes: IntArrayRef, @Const @ByRef dropout_state: Tensor[T, TT], @Const @ByRef reserve: Tensor[T, TT], @ByVal output_mask: ArrayBool4): TensorTripleAndVector[T,TT]
	@native @Namespace("at") @ByVal def _cudnn_init_dropout_state[T, TT <: TensorType](dropout: Double, @Cast(Array("bool")) train: Boolean, @Cast(Array("int64_t")) dropout_seed: CLongPointer, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _fused_dropout[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], p: Double, generator: Generator): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def _fused_dropout[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], p: Double): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def _masked_scale[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef mask: Tensor[Byte, TT], scale: Double): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _sobol_engine_draw[T, TT <: TensorType](@Const @ByRef quasi: Tensor[T, TT], @Cast(Array("int64_t")) n: CLongPointer, @Const @ByRef sobolstate: Tensor[T, TT], @Cast(Array("int64_t")) dimension: CLongPointer, @Cast(Array("int64_t")) num_generated: CLongPointer, @C10Optional dtype: ScalarType): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByRef def _sobol_engine_ff_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) n: CLongPointer, @Const @ByRef sobolstate: Tensor[T, TT], @Cast(Array("int64_t")) dimension: CLongPointer, @Cast(Array("int64_t")) num_generated: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _sobol_engine_scramble_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @Const @ByRef ltm: Tensor[T, TT], @Cast(Array("int64_t")) dimension: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _sobol_engine_initialize_state_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dimension: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _reshape_from_tensor[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef shape: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _shape_as_tensor[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def dropout[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], p: Double, @Cast(Array("bool")) train: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def dropout_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], p: Double, @Cast(Array("bool")) train: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def feature_dropout[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], p: Double, @Cast(Array("bool")) train: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def feature_dropout_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], p: Double, @Cast(Array("bool")) train: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def alpha_dropout[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], p: Double, @Cast(Array("bool")) train: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def alpha_dropout_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], p: Double, @Cast(Array("bool")) train: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def feature_alpha_dropout[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], p: Double, @Cast(Array("bool")) train: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def feature_alpha_dropout_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], p: Double, @Cast(Array("bool")) train: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def abs[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def abs_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def abs_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def acos[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def acos_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def acos_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def avg_pool1d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @Cast(Array("bool")) ceil_mode: Boolean, @Cast(Array("bool")) count_include_pad: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def avg_pool1d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def adaptive_avg_pool1d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal output_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def adaptive_max_pool1d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal output_size: IntArrayRef): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def add[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def add[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def add_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def add_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def add[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def add[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def addmv[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef mat: Tensor[T, TT], @Const @ByRef vec: Tensor[T, TT], @ByVal beta: Scalar[T], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def addmv[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef mat: Tensor[T, TT], @Const @ByRef vec: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def addmv_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @Const @ByRef mat: Tensor[T, TT], @Const @ByRef vec: Tensor[T, TT], @ByVal beta: Scalar[T], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def addmv_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @Const @ByRef mat: Tensor[T, TT], @Const @ByRef vec: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def addmv_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef mat: Tensor[T, TT], @Const @ByRef vec: Tensor[T, TT], @ByVal beta: Scalar[T], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def addmv_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef mat: Tensor[T, TT], @Const @ByRef vec: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def addr[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef vec1: Tensor[T, TT], @Const @ByRef vec2: Tensor[T, TT], @ByVal beta: Scalar[T], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def addr[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef vec1: Tensor[T, TT], @Const @ByRef vec2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def addr_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef vec1: Tensor[T, TT], @Const @ByRef vec2: Tensor[T, TT], @ByVal beta: Scalar[T], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def addr_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef vec1: Tensor[T, TT], @Const @ByRef vec2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def affine_grid_generator[T, TT <: TensorType](@Const @ByRef theta: Tensor[T, TT], @ByVal size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def affine_grid_generator_backward[T, TT <: TensorType](@Const @ByRef grad: Tensor[T, TT], @ByVal size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def all[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) keepdim: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def all[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def all_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) keepdim: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def all_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @Cast(Array("bool")) def allclose[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT], rtol: Double, atol: Double, @Cast(Array("bool")) equal_nan: Boolean): Boolean
	@native @Namespace("at") @Cast(Array("bool")) def allclose[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Boolean
	@native @Namespace("at") @ByVal def any[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) keepdim: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def any[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def any_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) keepdim: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def any_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def arange[T, TT <: TensorType](@ByVal end: Scalar[T], @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def arange[T](@ByVal end: Scalar[T]): Tensor[T, CPU]
	@native @Namespace("at") @ByVal def arange[T, TT <: TensorType](@ByVal start: Scalar[T], @ByVal end: Scalar[T], @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def arange[T](@ByVal start: Scalar[T], @ByVal end: Scalar[T]): Tensor[T, CPU]
	@native @Namespace("at") @ByVal def arange[T, TT <: TensorType](@ByVal start: Scalar[T], @ByVal end: Scalar[T], @ByVal step: Scalar[T], @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def arange[T](@ByVal start: Scalar[T], @ByVal end: Scalar[T], @ByVal step: Scalar[T]): Tensor[T, CPU]
	@native @Namespace("at") @ByRef def arange_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByVal end: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def arange_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByVal start: Scalar[T], @ByVal end: Scalar[T], @ByVal step: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def arange_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByVal start: Scalar[T], @ByVal end: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _dim_arange[T, TT <: TensorType](@Const @ByRef like: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def argmax[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t*")) @C10Optional dim: LongPointer, @Cast(Array("bool")) keepdim: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def argmax[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def argmax[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t*")) @C10Optional dim: LongBuffer, @Cast(Array("bool")) keepdim: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def argmax[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t*")) @C10Optional dim: Array[Long], @Cast(Array("bool")) keepdim: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def argmin[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t*")) @C10Optional dim: LongPointer, @Cast(Array("bool")) keepdim: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def argmin[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def argmin[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t*")) @C10Optional dim: LongBuffer, @Cast(Array("bool")) keepdim: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def argmin[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t*")) @C10Optional dim: Array[Long], @Cast(Array("bool")) keepdim: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def as_strided[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal size: IntArrayRef, @ByVal stride: IntArrayRef, @Cast(Array("int64_t*")) @C10Optional storage_offset: LongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def as_strided[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal size: IntArrayRef, @ByVal stride: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def as_strided[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal size: IntArrayRef, @ByVal stride: IntArrayRef, @Cast(Array("int64_t*")) @C10Optional storage_offset: LongBuffer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def as_strided[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal size: IntArrayRef, @ByVal stride: IntArrayRef, @Cast(Array("int64_t*")) @C10Optional storage_offset: Array[Long]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def as_strided_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @ByVal size: IntArrayRef, @ByVal stride: IntArrayRef, @Cast(Array("int64_t*")) @C10Optional storage_offset: LongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def as_strided_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @ByVal size: IntArrayRef, @ByVal stride: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def as_strided_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @ByVal size: IntArrayRef, @ByVal stride: IntArrayRef, @Cast(Array("int64_t*")) @C10Optional storage_offset: LongBuffer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def as_strided_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @ByVal size: IntArrayRef, @ByVal stride: IntArrayRef, @Cast(Array("int64_t*")) @C10Optional storage_offset: Array[Long]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def asin[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def asin_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def asin_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def atan[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def atan_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def atan_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def baddbmm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef batch1: Tensor[T, TT], @Const @ByRef batch2: Tensor[T, TT], @ByVal beta: Scalar[T], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def baddbmm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef batch1: Tensor[T, TT], @Const @ByRef batch2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _baddbmm_mkl_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @Const @ByRef batch1: Tensor[T, TT], @Const @ByRef batch2: Tensor[T, TT], @ByVal beta: Scalar[T], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _baddbmm_mkl_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @Const @ByRef batch1: Tensor[T, TT], @Const @ByRef batch2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def baddbmm_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef batch1: Tensor[T, TT], @Const @ByRef batch2: Tensor[T, TT], @ByVal beta: Scalar[T], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def baddbmm_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef batch1: Tensor[T, TT], @Const @ByRef batch2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def bartlett_window[T, TT <: TensorType](@Cast(Array("int64_t")) window_length: CLongPointer, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def bartlett_window(@Cast(Array("int64_t")) window_length: CLongPointer): Tensor[Double, CPU]
	@native @Namespace("at") @ByVal def bartlett_window[T, TT <: TensorType](@Cast(Array("int64_t")) window_length: CLongPointer, @Cast(Array("bool")) periodic: Boolean, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def bartlett_window(@Cast(Array("int64_t")) window_length: CLongPointer, @Cast(Array("bool")) periodic: Boolean): Tensor[Double, CPU]
	@native @Namespace("at") @ByVal def batch_norm[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT], @Const @ByRef running_mean: Tensor[T, TT], @Const @ByRef running_var: Tensor[T, TT], @Cast(Array("bool")) training: Boolean, momentum: Double, eps: Double, @Cast(Array("bool")) cudnn_enabled: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _batch_norm_impl_index[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT], @Const @ByRef running_mean: Tensor[T, TT], @Const @ByRef running_var: Tensor[T, TT], @Cast(Array("bool")) training: Boolean, momentum: Double, eps: Double, @Cast(Array("bool")) cudnn_enabled: Boolean): TensorTripleAndLong[T,TT]
	@native @Namespace("at") @ByVal def _batch_norm_impl_index_backward[T, TT <: TensorType](@Cast(Array("int64_t")) impl_index: CLongPointer, @Const @ByRef input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef running_mean: Tensor[T, TT], @Const @ByRef running_var: Tensor[T, TT], @Const @ByRef save_mean: Tensor[T, TT], @Const @ByRef save_var_transform: Tensor[T, TT], @Cast(Array("bool")) train: Boolean, eps: Double, @ByVal output_mask: ArrayBool3): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def bernoulli[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], generator: Generator): Tensor[T, TT]
	@native @Namespace("at") @ByVal def bernoulli[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def bernoulli_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], generator: Generator): Tensor[T, TT]
	@native @Namespace("at") @ByRef def bernoulli_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def bernoulli[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], p: Double, generator: Generator): Tensor[T, TT]
	@native @Namespace("at") @ByVal def bernoulli[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], p: Double): Tensor[T, TT]
	@native @Namespace("at") @ByVal def bilinear[T, TT <: TensorType](@Const @ByRef input1: Tensor[T, TT], @Const @ByRef input2: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def binary_cross_entropy_with_logits[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef pos_weight: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def binary_cross_entropy_with_logits[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def binary_cross_entropy_with_logits_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef pos_weight: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def binary_cross_entropy_with_logits_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def bincount[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef weights: Tensor[T, TT], @Cast(Array("int64_t")) minlength: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def bincount[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def blackman_window[T, TT <: TensorType](@Cast(Array("int64_t")) window_length: CLongPointer, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def blackman_window(@Cast(Array("int64_t")) window_length: CLongPointer): Tensor[Double, CPU]
	@native @Namespace("at") @ByVal def blackman_window[T, TT <: TensorType](@Cast(Array("int64_t")) window_length: CLongPointer, @Cast(Array("bool")) periodic: Boolean, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def blackman_window(@Cast(Array("int64_t")) window_length: CLongPointer, @Cast(Array("bool")) periodic: Boolean): Tensor[Double, CPU]
	@native @Namespace("at") @ByVal def bmm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef mat2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def bmm_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef mat2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @StdVector def broadcast_tensors[T, TT <: TensorType](@ByVal tensors: TensorList[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cat[T, TT <: TensorType](@ByVal tensors: TensorList[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cat[T, TT <: TensorType](@ByVal tensors: TensorList[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def cat_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByVal tensors: TensorList[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def cat_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByVal tensors: TensorList[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def ceil[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def ceil_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def ceil_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def chain_matmul[T, TT <: TensorType](@ByVal matrices: TensorList[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @StdVector def chunk[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) chunks: CLongPointer, @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @StdVector def chunk[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) chunks: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def clamp[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @C10Optional min: Scalar[T], @C10Optional max: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def clamp[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def clamp_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @C10Optional min: Scalar[T], @C10Optional max: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def clamp_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def clamp_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @C10Optional min: Scalar[T], @C10Optional max: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def clamp_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def clamp_max[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal max: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def clamp_max_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @ByVal max: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def clamp_max_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal max: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def clamp_min[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal min: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def clamp_min_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @ByVal min: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def clamp_min_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal min: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @Cast(Array("bool")) def cudnn_is_acceptable[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Boolean
	@native @Namespace("at") @ByVal def constant_pad_nd[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal pad: IntArrayRef, @ByVal value: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def constant_pad_nd[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal pad: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def convolution[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT], @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("bool")) transposed: Boolean, @ByVal output_padding: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _convolution[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT], @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("bool")) transposed: Boolean, @ByVal output_padding: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer, @Cast(Array("bool")) benchmark: Boolean, @Cast(Array("bool")) deterministic: Boolean, @Cast(Array("bool")) cudnn_enabled: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _convolution_nogroup[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT], @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("bool")) transposed: Boolean, @ByVal output_padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _convolution_double_backward[T, TT <: TensorType](@Const @ByRef ggI: Tensor[T, TT], @Const @ByRef ggW: Tensor[T, TT], @Const @ByRef ggb: Tensor[T, TT], @Const @ByRef gO: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("bool")) transposed: Boolean, @ByVal output_padding: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer, @Cast(Array("bool")) benchmark: Boolean, @Cast(Array("bool")) deterministic: Boolean, @Cast(Array("bool")) cudnn_enabled: Boolean, @ByVal output_mask: ArrayBool3): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def conv1d[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT], @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def conv1d[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def conv2d[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT], @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def conv2d[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def conv3d[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT], @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def conv3d[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def conv_tbc[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT], @Cast(Array("int64_t")) pad: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def conv_tbc[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def conv_tbc_backward[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT], @Cast(Array("int64_t")) pad: CLongPointer): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def conv_transpose1d[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT], @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal output_padding: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer, @ByVal dilation: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def conv_transpose1d[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def conv_transpose2d[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT], @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal output_padding: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer, @ByVal dilation: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def conv_transpose2d[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def conv_transpose3d[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT], @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal output_padding: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer, @ByVal dilation: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def conv_transpose3d[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _copy_from[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef dst: Tensor[T, TT], @Cast(Array("bool")) non_blocking: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _copy_from[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef dst: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cos[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def cos_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def cos_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cosh[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def cosh_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def cosh_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cosine_embedding_loss[T, TT <: TensorType](@Const @ByRef input1: Tensor[T, TT], @Const @ByRef input2: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], margin: Double, @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cosine_embedding_loss[T, TT <: TensorType](@Const @ByRef input1: Tensor[T, TT], @Const @ByRef input2: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cudnn_affine_grid_generator[T, TT <: TensorType](@Const @ByRef theta: Tensor[T, TT], @Cast(Array("int64_t")) N: CLongPointer, @Cast(Array("int64_t")) C: CLongPointer, @Cast(Array("int64_t")) H: CLongPointer, @Cast(Array("int64_t")) W: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cudnn_affine_grid_generator_backward[T, TT <: TensorType](@Const @ByRef grad: Tensor[T, TT], @Cast(Array("int64_t")) N: CLongPointer, @Cast(Array("int64_t")) C: CLongPointer, @Cast(Array("int64_t")) H: CLongPointer, @Cast(Array("int64_t")) W: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cudnn_batch_norm[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT], @Const @ByRef running_mean: Tensor[T, TT], @Const @ByRef running_var: Tensor[T, TT], @Cast(Array("bool")) training: Boolean, exponential_average_factor: Double, epsilon: Double): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def cudnn_batch_norm_backward[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef running_mean: Tensor[T, TT], @Const @ByRef running_var: Tensor[T, TT], @Const @ByRef save_mean: Tensor[T, TT], @Const @ByRef save_var: Tensor[T, TT], epsilon: Double): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def cudnn_convolution[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT], @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer, @Cast(Array("bool")) benchmark: Boolean, @Cast(Array("bool")) deterministic: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cudnn_convolution_backward_input[T, TT <: TensorType](@ByVal self_size: IntArrayRef, @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer, @Cast(Array("bool")) benchmark: Boolean, @Cast(Array("bool")) deterministic: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cudnn_convolution_backward[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer, @Cast(Array("bool")) benchmark: Boolean, @Cast(Array("bool")) deterministic: Boolean, @ByVal output_mask: ArrayBool3): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def cudnn_convolution_backward_bias[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cudnn_convolution_backward_weight[T, TT <: TensorType](@ByVal weight_size: IntArrayRef, @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer, @Cast(Array("bool")) benchmark: Boolean, @Cast(Array("bool")) deterministic: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cudnn_convolution_transpose[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT], @ByVal padding: IntArrayRef, @ByVal output_padding: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer, @Cast(Array("bool")) benchmark: Boolean, @Cast(Array("bool")) deterministic: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cudnn_convolution_transpose_backward[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal padding: IntArrayRef, @ByVal output_padding: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer, @Cast(Array("bool")) benchmark: Boolean, @Cast(Array("bool")) deterministic: Boolean, @ByVal output_mask: ArrayBool3): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def cudnn_convolution_transpose_backward_bias[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cudnn_convolution_transpose_backward_input[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer, @Cast(Array("bool")) benchmark: Boolean, @Cast(Array("bool")) deterministic: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cudnn_convolution_transpose_backward_weight[T, TT <: TensorType](@ByVal weight_size: IntArrayRef, @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer, @Cast(Array("bool")) benchmark: Boolean, @Cast(Array("bool")) deterministic: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cudnn_grid_sampler[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef grid: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cudnn_grid_sampler_backward[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef grid: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def cumsum[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @C10Optional dtype: ScalarType): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cumsum[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def cumsum_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @C10Optional dtype: ScalarType): Tensor[T, TT]
	@native @Namespace("at") @ByRef def cumsum_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cumprod[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @C10Optional dtype: ScalarType): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cumprod[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def cumprod_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @C10Optional dtype: ScalarType): Tensor[T, TT]
	@native @Namespace("at") @ByRef def cumprod_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def ctc_loss[T, TT <: TensorType](@Const @ByRef log_probs: Tensor[T, TT], @Const @ByRef targets: Tensor[T, TT], @ByVal input_lengths: IntArrayRef, @ByVal target_lengths: IntArrayRef, @Cast(Array("int64_t")) blank: CLongPointer, @Cast(Array("int64_t")) reduction: CLongPointer, @Cast(Array("bool")) zero_infinity: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def ctc_loss[T, TT <: TensorType](@Const @ByRef log_probs: Tensor[T, TT], @Const @ByRef targets: Tensor[T, TT], @ByVal input_lengths: IntArrayRef, @ByVal target_lengths: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def ctc_loss[T, TT <: TensorType](@Const @ByRef log_probs: Tensor[T, TT], @Const @ByRef targets: Tensor[T, TT], @Const @ByRef input_lengths: Tensor[T, TT], @Const @ByRef target_lengths: Tensor[T, TT], @Cast(Array("int64_t")) blank: CLongPointer, @Cast(Array("int64_t")) reduction: CLongPointer, @Cast(Array("bool")) zero_infinity: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def ctc_loss[T, TT <: TensorType](@Const @ByRef log_probs: Tensor[T, TT], @Const @ByRef targets: Tensor[T, TT], @Const @ByRef input_lengths: Tensor[T, TT], @Const @ByRef target_lengths: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _ctc_loss[T, TT <: TensorType](@Const @ByRef log_probs: Tensor[T, TT], @Const @ByRef targets: Tensor[T, TT], @ByVal input_lengths: IntArrayRef, @ByVal target_lengths: IntArrayRef, @Cast(Array("int64_t")) blank: CLongPointer, @Cast(Array("bool")) zero_infinity: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def _ctc_loss[T, TT <: TensorType](@Const @ByRef log_probs: Tensor[T, TT], @Const @ByRef targets: Tensor[T, TT], @ByVal input_lengths: IntArrayRef, @ByVal target_lengths: IntArrayRef): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def _ctc_loss_backward[T, TT <: TensorType](@Const @ByRef grad: Tensor[T, TT], @Const @ByRef log_probs: Tensor[T, TT], @Const @ByRef targets: Tensor[T, TT], @ByVal input_lengths: IntArrayRef, @ByVal target_lengths: IntArrayRef, @Const @ByRef neg_log_likelihood: Tensor[T, TT], @Const @ByRef log_alpha: Tensor[T, TT], @Cast(Array("int64_t")) blank: CLongPointer, @Cast(Array("bool")) zero_infinity: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _ctc_loss_backward[T, TT <: TensorType](@Const @ByRef grad: Tensor[T, TT], @Const @ByRef log_probs: Tensor[T, TT], @Const @ByRef targets: Tensor[T, TT], @ByVal input_lengths: IntArrayRef, @ByVal target_lengths: IntArrayRef, @Const @ByRef neg_log_likelihood: Tensor[T, TT], @Const @ByRef log_alpha: Tensor[T, TT], @Cast(Array("int64_t")) blank: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def det[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def diag_embed[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) offset: CLongPointer, @Cast(Array("int64_t")) dim1: CLongPointer, @Cast(Array("int64_t")) dim2: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def diag_embed[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def diagflat[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) offset: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def diagflat[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def diagonal[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) offset: CLongPointer, @Cast(Array("int64_t")) dim1: CLongPointer, @Cast(Array("int64_t")) dim2: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def diagonal[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def div[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def div_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def div[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def dot[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef tensor: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def dot_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef tensor: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def einsum[T, TT <: TensorType](@StdString equation: BytePointer, @ByVal tensors: TensorList[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def einsum[T, TT <: TensorType](@StdString equation: String, @ByVal tensors: TensorList[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def embedding[T, TT <: TensorType](@Const @ByRef weight: Tensor[T, TT], @Const @ByRef indices: Tensor[Long, TT], @Cast(Array("int64_t")) padding_idx: CLongPointer, @Cast(Array("bool")) scale_grad_by_freq: Boolean, @Cast(Array("bool")) sparse: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def embedding[T, TT <: TensorType](@Const @ByRef weight: Tensor[T, TT], @Const @ByRef indices: Tensor[Long, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def embedding_backward[T, TT <: TensorType](@Const @ByRef grad: Tensor[T, TT], @Const @ByRef indices: Tensor[Long, TT], @Cast(Array("int64_t")) num_weights: CLongPointer, @Cast(Array("int64_t")) padding_idx: CLongPointer, @Cast(Array("bool")) scale_grad_by_freq: Boolean, @Cast(Array("bool")) sparse: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def embedding_dense_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef indices: Tensor[Long, TT], @Cast(Array("int64_t")) num_weights: CLongPointer, @Cast(Array("int64_t")) padding_idx: CLongPointer, @Cast(Array("bool")) scale_grad_by_freq: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def embedding_renorm_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @Const @ByRef indices: Tensor[Long, TT], max_norm: Double, norm_type: Double): Tensor[T, TT]
	@native @Namespace("at") @ByVal def embedding_sparse_backward[T, TT <: TensorType](@Const @ByRef grad: Tensor[T, TT], @Const @ByRef indices: Tensor[Long, TT], @Cast(Array("int64_t")) num_weights: CLongPointer, @Cast(Array("int64_t")) padding_idx: CLongPointer, @Cast(Array("bool")) scale_grad_by_freq: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def embedding_bag[T, TT <: TensorType](@Const @ByRef weight: Tensor[T, TT], @Const @ByRef indices: Tensor[Long, TT], @Const @ByRef offsets: Tensor[T, TT], @Cast(Array("bool")) scale_grad_by_freq: Boolean, @Cast(Array("int64_t")) mode: CLongPointer, @Cast(Array("bool")) sparse: Boolean, @Const @ByRef per_sample_weights: Tensor[T, TT]): TensorTuple4[T,TT]
	@native @Namespace("at") @ByVal def embedding_bag[T, TT <: TensorType](@Const @ByRef weight: Tensor[T, TT], @Const @ByRef indices: Tensor[Long, TT], @Const @ByRef offsets: Tensor[T, TT]): TensorTuple4[T,TT]
	@native @Namespace("at") @ByVal def _embedding_bag[T, TT <: TensorType](@Const @ByRef weight: Tensor[T, TT], @Const @ByRef indices: Tensor[Long, TT], @Const @ByRef offsets: Tensor[T, TT], @Cast(Array("bool")) scale_grad_by_freq: Boolean, @Cast(Array("int64_t")) mode: CLongPointer, @Cast(Array("bool")) sparse: Boolean, @Const @ByRef per_sample_weights: Tensor[T, TT]): TensorTuple4[T,TT]
	@native @Namespace("at") @ByVal def _embedding_bag[T, TT <: TensorType](@Const @ByRef weight: Tensor[T, TT], @Const @ByRef indices: Tensor[Long, TT], @Const @ByRef offsets: Tensor[T, TT]): TensorTuple4[T,TT]
	@native @Namespace("at") @ByVal def _embedding_bag_backward[T, TT <: TensorType](@Const @ByRef grad: Tensor[T, TT], @Const @ByRef indices: Tensor[Long, TT], @Const @ByRef offsets: Tensor[T, TT], @Const @ByRef offset2bag: Tensor[T, TT], @Const @ByRef bag_size: Tensor[T, TT], @Const @ByRef maximum_indices: Tensor[Long, TT], @Cast(Array("int64_t")) num_weights: CLongPointer, @Cast(Array("bool")) scale_grad_by_freq: Boolean, @Cast(Array("int64_t")) mode: CLongPointer, @Cast(Array("bool")) sparse: Boolean, @Const @ByRef per_sample_weights: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _embedding_bag_sparse_backward[T, TT <: TensorType](@Const @ByRef grad: Tensor[T, TT], @Const @ByRef indices: Tensor[Long, TT], @Const @ByRef offsets: Tensor[T, TT], @Const @ByRef offset2bag: Tensor[T, TT], @Const @ByRef bag_size: Tensor[T, TT], @Cast(Array("int64_t")) num_weights: CLongPointer, @Cast(Array("bool")) scale_grad_by_freq: Boolean, @Cast(Array("int64_t")) mode: CLongPointer, @Const @ByRef per_sample_weights: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _embedding_bag_dense_backward[T, TT <: TensorType](@Const @ByRef grad: Tensor[T, TT], @Const @ByRef indices: Tensor[Long, TT], @Const @ByRef offsets: Tensor[T, TT], @Const @ByRef offset2bag: Tensor[T, TT], @Const @ByRef bag_size: Tensor[T, TT], @Const @ByRef maximum_indices: Tensor[Long, TT], @Cast(Array("int64_t")) num_weights: CLongPointer, @Cast(Array("bool")) scale_grad_by_freq: Boolean, @Cast(Array("int64_t")) mode: CLongPointer, @Const @ByRef per_sample_weights: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _embedding_bag_per_sample_weights_backward[T, TT <: TensorType](@Const @ByRef grad: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef indices: Tensor[Long, TT], @Const @ByRef offsets: Tensor[T, TT], @Const @ByRef offset2bag: Tensor[T, TT], @Cast(Array("int64_t")) mode: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def empty[T, TT <: TensorType](@ByVal size: IntArrayRef, @Const @ByRef options: TensorOptions[T, TT], @C10Optional memory_format: MemoryFormat): Tensor[T, TT]
	@native @Namespace("at") @ByVal def empty(@ByVal size: IntArrayRef): Tensor[Double, CPU]
	@native @Namespace("at") @ByVal def _empty_affine_quantized[T, TT <: TensorType](@ByVal size: IntArrayRef, @Const @ByRef options: TensorOptions[T, TT], scale: Double, @Cast(Array("int64_t")) zero_point: CLongPointer, @C10Optional memory_format: MemoryFormat): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _empty_affine_quantized(@ByVal size: IntArrayRef): Tensor[Double, CPU]
	@native @Namespace("at") @ByRef def empty_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByVal size: IntArrayRef, @C10Optional memory_format: MemoryFormat): Tensor[T, TT]
	@native @Namespace("at") @ByRef def empty_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByVal size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def empty_like[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def empty_like[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef options: TensorOptions[T, TT], @C10Optional memory_format: MemoryFormat): Tensor[T, TT]
	@native @Namespace("at") @ByVal def empty_like[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def empty_strided[T, TT <: TensorType](@ByVal size: IntArrayRef, @ByVal stride: IntArrayRef, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def empty_strided(@ByVal size: IntArrayRef, @ByVal stride: IntArrayRef): Tensor[Double, CPU]
	@native @Namespace("at") @ByVal def erf[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def erf_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def erf_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def erfc[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def erfc_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def erfc_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def exp[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def exp_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def exp_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def expm1[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def expm1_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def expm1_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def eye[T, TT <: TensorType](@Cast(Array("int64_t")) n: CLongPointer, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def eye(@Cast(Array("int64_t")) n: CLongPointer): Tensor[Double, CPU]
	@native @Namespace("at") @ByVal def eye[T, TT <: TensorType](@Cast(Array("int64_t")) n: CLongPointer, @Cast(Array("int64_t")) m: CLongPointer, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def eye(@Cast(Array("int64_t")) n: CLongPointer, @Cast(Array("int64_t")) m: CLongPointer): Tensor[Double, CPU]
	@native @Namespace("at") @ByRef def eye_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Cast(Array("int64_t")) n: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def eye_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Cast(Array("int64_t")) n: CLongPointer, @Cast(Array("int64_t")) m: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def flatten[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) start_dim: CLongPointer, @Cast(Array("int64_t")) end_dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def flatten[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def fill_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @ByVal value: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def fill_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @Const @ByRef value: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def floor[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def floor_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def floor_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def frac[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def frac_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def frac_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def full[T, TT <: TensorType](@ByVal size: IntArrayRef, @ByVal fill_value: Scalar[T], @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def full[T](@ByVal size: IntArrayRef, @ByVal fill_value: Scalar[T]): Tensor[T, CPU]
	@native @Namespace("at") @ByRef def full_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByVal size: IntArrayRef, @ByVal fill_value: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def full_like[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal fill_value: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def full_like[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal fill_value: Scalar[T], @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def from_file[T, TT <: TensorType](@StdString filename: BytePointer, @Cast(Array("bool*")) @C10Optional shared: BoolPointer, @Cast(Array("int64_t*")) @C10Optional size: LongPointer, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def from_file(@StdString filename: BytePointer): Tensor[Double, CPU]
	@native @Namespace("at") @ByVal def from_file[T, TT <: TensorType](@StdString filename: String, @Cast(Array("bool*")) @C10Optional shared: Array[Boolean], @Cast(Array("int64_t*")) @C10Optional size: LongBuffer, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def from_file(@StdString filename: String): Tensor[Double, CPU]
	@native @Namespace("at") @ByVal def from_file[T, TT <: TensorType](@StdString filename: BytePointer, @Cast(Array("bool*")) @C10Optional shared: BoolPointer, @Cast(Array("int64_t*")) @C10Optional size: Array[Long], @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def from_file[T, TT <: TensorType](@StdString filename: String, @Cast(Array("bool*")) @C10Optional shared: Array[Boolean], @Cast(Array("int64_t*")) @C10Optional size: LongPointer, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def from_file[T, TT <: TensorType](@StdString filename: BytePointer, @Cast(Array("bool*")) @C10Optional shared: BoolPointer, @Cast(Array("int64_t*")) @C10Optional size: LongBuffer, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def from_file[T, TT <: TensorType](@StdString filename: String, @Cast(Array("bool*")) @C10Optional shared: Array[Boolean], @Cast(Array("int64_t*")) @C10Optional size: Array[Long], @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def grid_sampler[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef grid: Tensor[T, TT], @Cast(Array("int64_t")) interpolation_mode: CLongPointer, @Cast(Array("int64_t")) padding_mode: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def grid_sampler_2d[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef grid: Tensor[T, TT], @Cast(Array("int64_t")) interpolation_mode: CLongPointer, @Cast(Array("int64_t")) padding_mode: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def grid_sampler_2d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef input: Tensor[T, TT], @Const @ByRef grid: Tensor[T, TT], @Cast(Array("int64_t")) interpolation_mode: CLongPointer, @Cast(Array("int64_t")) padding_mode: CLongPointer): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def grid_sampler_3d[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef grid: Tensor[T, TT], @Cast(Array("int64_t")) interpolation_mode: CLongPointer, @Cast(Array("int64_t")) padding_mode: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def grid_sampler_3d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef input: Tensor[T, TT], @Const @ByRef grid: Tensor[T, TT], @Cast(Array("int64_t")) interpolation_mode: CLongPointer, @Cast(Array("int64_t")) padding_mode: CLongPointer): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def hann_window[T, TT <: TensorType](@Cast(Array("int64_t")) window_length: CLongPointer, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def hann_window(@Cast(Array("int64_t")) window_length: CLongPointer): Tensor[Double, CPU]
	@native @Namespace("at") @ByVal def hann_window[T, TT <: TensorType](@Cast(Array("int64_t")) window_length: CLongPointer, @Cast(Array("bool")) periodic: Boolean, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def hann_window(@Cast(Array("int64_t")) window_length: CLongPointer, @Cast(Array("bool")) periodic: Boolean): Tensor[Double, CPU]
	@native @Namespace("at") @ByVal def hamming_window[T, TT <: TensorType](@Cast(Array("int64_t")) window_length: CLongPointer, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def hamming_window(@Cast(Array("int64_t")) window_length: CLongPointer): Tensor[Double, CPU]
	@native @Namespace("at") @ByVal def hamming_window[T, TT <: TensorType](@Cast(Array("int64_t")) window_length: CLongPointer, @Cast(Array("bool")) periodic: Boolean, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def hamming_window(@Cast(Array("int64_t")) window_length: CLongPointer, @Cast(Array("bool")) periodic: Boolean): Tensor[Double, CPU]
	@native @Namespace("at") @ByVal def hamming_window[T, TT <: TensorType](@Cast(Array("int64_t")) window_length: CLongPointer, @Cast(Array("bool")) periodic: Boolean, alpha: Double, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def hamming_window(@Cast(Array("int64_t")) window_length: CLongPointer, @Cast(Array("bool")) periodic: Boolean, alpha: Double): Tensor[Double, CPU]
	@native @Namespace("at") @ByVal def hamming_window[T, TT <: TensorType](@Cast(Array("int64_t")) window_length: CLongPointer, @Cast(Array("bool")) periodic: Boolean, alpha: Double, beta: Double, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def hamming_window(@Cast(Array("int64_t")) window_length: CLongPointer, @Cast(Array("bool")) periodic: Boolean, alpha: Double, beta: Double): Tensor[Double, CPU]
	@native @Namespace("at") @ByVal def hinge_embedding_loss[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], margin: Double, @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def hinge_embedding_loss[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def ger[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef vec2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def ger_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef vec2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def group_norm[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Cast(Array("int64_t")) num_groups: CLongPointer, @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT], eps: Double, @Cast(Array("bool")) cudnn_enabled: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def group_norm[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Cast(Array("int64_t")) num_groups: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def fft[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) signal_ndim: CLongPointer, @Cast(Array("bool")) normalized: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def fft[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) signal_ndim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def ifft[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) signal_ndim: CLongPointer, @Cast(Array("bool")) normalized: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def ifft[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) signal_ndim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def rfft[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) signal_ndim: CLongPointer, @Cast(Array("bool")) normalized: Boolean, @Cast(Array("bool")) onesided: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def rfft[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) signal_ndim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def irfft[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) signal_ndim: CLongPointer, @Cast(Array("bool")) normalized: Boolean, @Cast(Array("bool")) onesided: Boolean, @ByVal signal_sizes: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def irfft[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) signal_ndim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _fft_with_size[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) signal_ndim: CLongPointer, @Cast(Array("bool")) complex_input: Boolean, @Cast(Array("bool")) complex_output: Boolean, @Cast(Array("bool")) inverse: Boolean, @ByVal checked_signal_sizes: IntArrayRef, @Cast(Array("bool")) normalized: Boolean, @Cast(Array("bool")) onesided: Boolean, @ByVal output_sizes: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") def _cufft_set_plan_cache_max_size(@Cast(Array("int64_t")) device_index: CLongPointer, @Cast(Array("int64_t")) max_size: CLongPointer): Unit
	@native @Namespace("at") def _cufft_clear_plan_cache(@Cast(Array("int64_t")) device_index: CLongPointer): Unit
	@native @Namespace("at") @ByVal def index[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal indices: TensorList[Long, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def index_copy[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Const @ByRef index: Tensor[Long, TT], @Const @ByRef source: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def index_put_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @ByVal indices: TensorList[Long, TT], @Const @ByRef values: Tensor[T, TT], @Cast(Array("bool")) accumulate: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def index_put_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @ByVal indices: TensorList[Long, TT], @Const @ByRef values: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def index_put[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal indices: TensorList[Long, TT], @Const @ByRef values: Tensor[T, TT], @Cast(Array("bool")) accumulate: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def index_put[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal indices: TensorList[Long, TT], @Const @ByRef values: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _index_put_impl_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @ByVal indices: TensorList[Long, TT], @Const @ByRef values: Tensor[T, TT], @Cast(Array("bool")) accumulate: Boolean, @Cast(Array("bool")) unsafe: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _index_put_impl_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @ByVal indices: TensorList[Long, TT], @Const @ByRef values: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def instance_norm[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT], @Const @ByRef running_mean: Tensor[T, TT], @Const @ByRef running_var: Tensor[T, TT], @Cast(Array("bool")) use_input_stats: Boolean, momentum: Double, eps: Double, @Cast(Array("bool")) cudnn_enabled: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def inverse[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def inverse_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _inverse_helper[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def isclose[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT], rtol: Double, atol: Double, @Cast(Array("bool")) equal_nan: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def isclose[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def isnan[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @Cast(Array("bool")) def is_distributed[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Boolean
	@native @Namespace("at") @Cast(Array("bool")) def is_floating_point[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Boolean
	@native @Namespace("at") @Cast(Array("bool")) def is_complex[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Boolean
	@native @Namespace("at") @Cast(Array("bool")) def is_nonzero[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Boolean
	@native @Namespace("at") @Cast(Array("bool")) def is_same_size[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Boolean
	@native @Namespace("at") @Cast(Array("bool")) def is_signed[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Boolean
	@native @Namespace("at") @ByVal def kl_div[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def kl_div[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def kl_div_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def kl_div_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def kthvalue[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) k: CLongPointer, @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) keepdim: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def kthvalue[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) k: CLongPointer): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def kthvalue_out[T, TT <: TensorType](@ByRef values: Tensor[T, TT], @ByRef indices: Tensor[Long, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) k: CLongPointer, @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) keepdim: Boolean): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def kthvalue_out[T, TT <: TensorType](@ByRef values: Tensor[T, TT], @ByRef indices: Tensor[Long, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) k: CLongPointer): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def layer_norm[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @ByVal normalized_shape: IntArrayRef, @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT], eps: Double, @Cast(Array("bool")) cudnn_enable: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def layer_norm[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @ByVal normalized_shape: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def native_layer_norm[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT], @Cast(Array("int64_t")) M: CLongPointer, @Cast(Array("int64_t")) N: CLongPointer, eps: Double): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def native_layer_norm_backward[T, TT <: TensorType](@Const @ByRef grad_out: Tensor[T, TT], @Const @ByRef input: Tensor[T, TT], @Const @ByRef mean: Tensor[T, TT], @Const @ByRef rstd: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Cast(Array("int64_t")) M: CLongPointer, @Cast(Array("int64_t")) N: CLongPointer, @ByVal output_mask: ArrayBool3): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def native_layer_norm_double_backward[T, TT <: TensorType](@Const @ByRef ggI: Tensor[T, TT], @Const @ByRef ggW: Tensor[T, TT], @Const @ByRef ggb: Tensor[T, TT], @Const @ByRef gO: Tensor[T, TT], @Const @ByRef input: Tensor[T, TT], @Const @ByRef mean: Tensor[T, TT], @Const @ByRef rstd: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Cast(Array("int64_t")) M: CLongPointer, @Cast(Array("int64_t")) N: CLongPointer, @ByVal output_mask: ArrayBool3): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def linear[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def linear[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def mkldnn_linear[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def mkldnn_linear[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def fbgemm_linear_int8_weight[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef packed: Tensor[T, TT], @Const @ByRef col_offsets: Tensor[T, TT], @ByVal weight_scale: Scalar[T], @ByVal weight_zero_point: Scalar[T], @Const @ByRef bias: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def fbgemm_linear_quantize_weight[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT]): TensorTupleAndDoubleLong[T,TT]
	@native @Namespace("at") @ByVal def fbgemm_pack_quantized_matrix[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Cast(Array("int64_t")) K: CLongPointer, @Cast(Array("int64_t")) N: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @Cast(Array("bool")) def fbgemm_is_cpu_supported(): Boolean
	@native @Namespace("at") @ByVal def linspace[T, TT <: TensorType](@ByVal start: Scalar[T], @ByVal end: Scalar[T], @Cast(Array("int64_t")) steps: CLongPointer, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def linspace[T](@ByVal start: Scalar[T], @ByVal end: Scalar[T]): Tensor[T, CPU]
	@native @Namespace("at") @ByRef def linspace_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByVal start: Scalar[T], @ByVal end: Scalar[T], @Cast(Array("int64_t")) steps: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def linspace_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByVal start: Scalar[T], @ByVal end: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def log[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def log_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def log_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def log10[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def log10_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def log10_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def log1p[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def log1p_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def log1p_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def log2[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def log2_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def log2_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def logdet[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def logspace[T, TT <: TensorType](@ByVal start: Scalar[T], @ByVal end: Scalar[T], @Cast(Array("int64_t")) steps: CLongPointer, base: Double, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def logspace[T](@ByVal start: Scalar[T], @ByVal end: Scalar[T]): Tensor[T, CPU]
	@native @Namespace("at") @ByRef def logspace_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByVal start: Scalar[T], @ByVal end: Scalar[T], @Cast(Array("int64_t")) steps: CLongPointer, base: Double): Tensor[T, TT]
	@native @Namespace("at") @ByRef def logspace_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByVal start: Scalar[T], @ByVal end: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def log_softmax[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @C10Optional dtype: ScalarType): Tensor[T, TT]
	@native @Namespace("at") @ByVal def log_softmax[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _log_softmax[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) half_to_float: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _log_softmax_backward_data[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef output: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def logsumexp[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef, @Cast(Array("bool")) keepdim: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def logsumexp[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def logsumexp_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef, @Cast(Array("bool")) keepdim: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def logsumexp_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def margin_ranking_loss[T, TT <: TensorType](@Const @ByRef input1: Tensor[T, TT], @Const @ByRef input2: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], margin: Double, @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def margin_ranking_loss[T, TT <: TensorType](@Const @ByRef input1: Tensor[T, TT], @Const @ByRef input2: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def matmul[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def matmul_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def matrix_rank[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], tol: Double, @Cast(Array("bool")) symmetric: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def matrix_rank[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], tol: Double): Tensor[T, TT]
	@native @Namespace("at") @ByVal def matrix_rank[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) symmetric: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def matrix_rank[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def matrix_power[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) n: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def max[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) keepdim: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def max[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def max_out[T, TT <: TensorType](@ByRef max: Tensor[T, TT], @ByRef max_values: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) keepdim: Boolean): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def max_out[T, TT <: TensorType](@ByRef max: Tensor[T, TT], @ByRef max_values: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def max_values[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef, @Cast(Array("bool")) keepdim: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def max_values[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def max_pool1d_with_indices[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("bool")) ceil_mode: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def max_pool1d_with_indices[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def max_pool1d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("bool")) ceil_mode: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def max_pool1d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def max_pool2d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("bool")) ceil_mode: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def max_pool2d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def mkldnn_max_pool2d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("bool")) ceil_mode: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def mkldnn_max_pool2d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def max_pool3d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("bool")) ceil_mode: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def max_pool3d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def mean[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @C10Optional dtype: ScalarType): Tensor[T, TT]
	@native @Namespace("at") @ByVal def mean[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def mean[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef, @Cast(Array("bool")) keepdim: Boolean, @C10Optional dtype: ScalarType): Tensor[T, TT]
	@native @Namespace("at") @ByVal def mean[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def mean_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef, @Cast(Array("bool")) keepdim: Boolean, @C10Optional dtype: ScalarType): Tensor[T, TT]
	@native @Namespace("at") @ByRef def mean_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def median[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) keepdim: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def median[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def median_out[T, TT <: TensorType](@ByRef values: Tensor[T, TT], @ByRef indices: Tensor[Long, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) keepdim: Boolean): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def median_out[T, TT <: TensorType](@ByRef values: Tensor[T, TT], @ByRef indices: Tensor[Long, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def min[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) keepdim: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def min[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def min_out[T, TT <: TensorType](@ByRef min: Tensor[T, TT], @ByRef min_indices: Tensor[Long, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) keepdim: Boolean): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def min_out[T, TT <: TensorType](@ByRef min: Tensor[T, TT], @ByRef min_indices: Tensor[Long, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def min_values[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef, @Cast(Array("bool")) keepdim: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def min_values[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def mkldnn_convolution[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT], @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def mkldnn_convolution_backward_input[T, TT <: TensorType](@ByVal self_size: IntArrayRef, @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer, @Cast(Array("bool")) bias_defined: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def mkldnn_convolution_backward_weights[T, TT <: TensorType](@ByVal weight_size: IntArrayRef, @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer, @Cast(Array("bool")) bias_defined: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def mkldnn_convolution_backward[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer, @ByVal output_mask: ArrayBool3): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def miopen_batch_norm[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT], @Const @ByRef running_mean: Tensor[T, TT], @Const @ByRef running_var: Tensor[T, TT], @Cast(Array("bool")) training: Boolean, exponential_average_factor: Double, epsilon: Double): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def miopen_batch_norm_backward[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef running_mean: Tensor[T, TT], @Const @ByRef running_var: Tensor[T, TT], @Const @ByRef save_mean: Tensor[T, TT], @Const @ByRef save_var: Tensor[T, TT], epsilon: Double): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def miopen_convolution[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT], @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer, @Cast(Array("bool")) benchmark: Boolean, @Cast(Array("bool")) deterministic: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def miopen_convolution_backward_input[T, TT <: TensorType](@ByVal self_size: IntArrayRef, @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer, @Cast(Array("bool")) benchmark: Boolean, @Cast(Array("bool")) deterministic: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def miopen_convolution_backward[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer, @Cast(Array("bool")) benchmark: Boolean, @Cast(Array("bool")) deterministic: Boolean, @ByVal output_mask: ArrayBool3): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def miopen_convolution_backward_bias[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def miopen_convolution_backward_weight[T, TT <: TensorType](@ByVal weight_size: IntArrayRef, @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer, @Cast(Array("bool")) benchmark: Boolean, @Cast(Array("bool")) deterministic: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def miopen_convolution_transpose[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT], @ByVal padding: IntArrayRef, @ByVal output_padding: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer, @Cast(Array("bool")) benchmark: Boolean, @Cast(Array("bool")) deterministic: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def miopen_convolution_transpose_backward[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal padding: IntArrayRef, @ByVal output_padding: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer, @Cast(Array("bool")) benchmark: Boolean, @Cast(Array("bool")) deterministic: Boolean, @ByVal output_mask: ArrayBool3): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def miopen_convolution_transpose_backward_input[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer, @Cast(Array("bool")) benchmark: Boolean, @Cast(Array("bool")) deterministic: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def miopen_convolution_transpose_backward_weight[T, TT <: TensorType](@ByVal weight_size: IntArrayRef, @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer, @Cast(Array("bool")) benchmark: Boolean, @Cast(Array("bool")) deterministic: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def miopen_depthwise_convolution[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT], @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer, @Cast(Array("bool")) benchmark: Boolean, @Cast(Array("bool")) deterministic: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def miopen_depthwise_convolution_backward_input[T, TT <: TensorType](@ByVal self_size: IntArrayRef, @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer, @Cast(Array("bool")) benchmark: Boolean, @Cast(Array("bool")) deterministic: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def miopen_depthwise_convolution_backward[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer, @Cast(Array("bool")) benchmark: Boolean, @Cast(Array("bool")) deterministic: Boolean, @ByVal output_mask: ArrayBool3): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def miopen_depthwise_convolution_backward_weight[T, TT <: TensorType](@ByVal weight_size: IntArrayRef, @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer, @Cast(Array("bool")) benchmark: Boolean, @Cast(Array("bool")) deterministic: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def mm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef mat2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def mm_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef mat2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _sparse_mm[T, TT <: TensorType](@Const @ByRef sparse: Tensor[T, TT], @Const @ByRef dense: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def mode[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) keepdim: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def mode[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def mode_out[T, TT <: TensorType](@ByRef values: Tensor[T, TT], @ByRef indices: Tensor[Long, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) keepdim: Boolean): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def mode_out[T, TT <: TensorType](@ByRef values: Tensor[T, TT], @ByRef indices: Tensor[Long, TT], @Const @ByRef self: Tensor[T, TT]): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def mul[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def mul_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def mul[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def mv[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef vec: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def mv_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef vec: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def mvlgamma[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) p: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def narrow[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("int64_t")) start: CLongPointer, @Cast(Array("int64_t")) length: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def native_batch_norm[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT], @Const @ByRef running_mean: Tensor[T, TT], @Const @ByRef running_var: Tensor[T, TT], @Cast(Array("bool")) training: Boolean, momentum: Double, eps: Double): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def batch_norm_stats[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], eps: Double): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def batch_norm_elemt[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT], @Const @ByRef mean: Tensor[T, TT], @Const @ByRef invstd: Tensor[T, TT], eps: Double): Tensor[T, TT]
	@native @Namespace("at") @ByVal def batch_norm_gather_stats[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef mean: Tensor[T, TT], @Const @ByRef invstd: Tensor[T, TT], @Const @ByRef running_mean: Tensor[T, TT], @Const @ByRef running_var: Tensor[T, TT], momentum: Double, eps: Double, @Cast(Array("int64_t")) count: CLongPointer): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def batch_norm_gather_stats_with_counts[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef mean: Tensor[T, TT], @Const @ByRef invstd: Tensor[T, TT], @Const @ByRef running_mean: Tensor[T, TT], @Const @ByRef running_var: Tensor[T, TT], momentum: Double, eps: Double, @ByVal counts: IntArrayRef): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def native_batch_norm_backward[T, TT <: TensorType](@Const @ByRef grad_out: Tensor[T, TT], @Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef running_mean: Tensor[T, TT], @Const @ByRef running_var: Tensor[T, TT], @Const @ByRef save_mean: Tensor[T, TT], @Const @ByRef save_invstd: Tensor[T, TT], @Cast(Array("bool")) train: Boolean, eps: Double, @ByVal output_mask: ArrayBool3): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def batch_norm_backward_reduce[T, TT <: TensorType](@Const @ByRef grad_out: Tensor[T, TT], @Const @ByRef input: Tensor[T, TT], @Const @ByRef mean: Tensor[T, TT], @Const @ByRef invstd: Tensor[T, TT], @Cast(Array("bool")) input_g: Boolean, @Cast(Array("bool")) weight_g: Boolean, @Cast(Array("bool")) bias_g: Boolean): TensorTuple4[T,TT]
	@native @Namespace("at") @ByVal def batch_norm_backward_elemt[T, TT <: TensorType](@Const @ByRef grad_out: Tensor[T, TT], @Const @ByRef input: Tensor[T, TT], @Const @ByRef mean: Tensor[T, TT], @Const @ByRef invstd: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef mean_dy: Tensor[T, TT], @Const @ByRef mean_dy_xmu: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def batch_norm_update_stats[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef running_mean: Tensor[T, TT], @Const @ByRef running_var: Tensor[T, TT], momentum: Double): TensorTuple[T,T,TT]
	@native @Namespace("at") @Cast(Array("bool")) def _nnpack_available(): Boolean
	@native @Namespace("at") @ByVal def _nnpack_spatial_convolution[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Const @ByRef bias: Tensor[T, TT], @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _nnpack_spatial_convolution_backward[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal padding: IntArrayRef, @ByVal output_mask: ArrayBool3): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def _nnpack_spatial_convolution_backward_input[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _nnpack_spatial_convolution_backward_weight[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @ByVal weightsize: IntArrayRef, @Const @ByRef grad_output: Tensor[T, TT], @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def ones[T, TT <: TensorType](@ByVal size: IntArrayRef, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def ones(@ByVal size: IntArrayRef): Tensor[Double, CPU]
	@native @Namespace("at") @ByRef def ones_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByVal size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def ones_like[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def ones_like[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def pairwise_distance[T, TT <: TensorType](@Const @ByRef x1: Tensor[T, TT], @Const @ByRef x2: Tensor[T, TT], p: Double, eps: Double, @Cast(Array("bool")) keepdim: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def pairwise_distance[T, TT <: TensorType](@Const @ByRef x1: Tensor[T, TT], @Const @ByRef x2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cdist[T, TT <: TensorType](@Const @ByRef x1: Tensor[T, TT], @Const @ByRef x2: Tensor[T, TT], p: Double): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cdist[T, TT <: TensorType](@Const @ByRef x1: Tensor[T, TT], @Const @ByRef x2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _cdist_backward[T, TT <: TensorType](@Const @ByRef grad: Tensor[T, TT], @Const @ByRef x1: Tensor[T, TT], @Const @ByRef x2: Tensor[T, TT], p: Double, @Const @ByRef cdist: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def pdist[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], p: Double): Tensor[T, TT]
	@native @Namespace("at") @ByVal def pdist[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _pdist_forward[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], p: Double): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _pdist_forward[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _pdist_backward[T, TT <: TensorType](@Const @ByRef grad: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], p: Double, @Const @ByRef pdist: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cosine_similarity[T, TT <: TensorType](@Const @ByRef x1: Tensor[T, TT], @Const @ByRef x2: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, eps: Double): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cosine_similarity[T, TT <: TensorType](@Const @ByRef x1: Tensor[T, TT], @Const @ByRef x2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def pixel_shuffle[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) upscale_factor: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def pin_memory[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def pinverse[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], rcond: Double): Tensor[T, TT]
	@native @Namespace("at") @ByVal def pinverse[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def poisson_nll_loss[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Cast(Array("bool")) log_input: Boolean, @Cast(Array("bool")) full: Boolean, eps: Double, @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def scalar_tensor[T, TT <: TensorType](@ByVal s: Scalar[T], @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def scalar_tensor[T](@ByVal s: Scalar[T]): Tensor[T, CPU]
	@native @Namespace("at") @ByVal def rand[T, TT <: TensorType](@ByVal size: IntArrayRef, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def rand(@ByVal size: IntArrayRef): Tensor[Double, CPU]
	@native @Namespace("at") @ByVal def rand[T, TT <: TensorType](@ByVal size: IntArrayRef, generator: Generator, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def rand(@ByVal size: IntArrayRef, generator: Generator): Tensor[Double, CPU]
	@native @Namespace("at") @ByRef def rand_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByVal size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def rand_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByVal size: IntArrayRef, generator: Generator): Tensor[T, TT]
	@native @Namespace("at") @ByVal def rand_like[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def rand_like[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def randint[T, TT <: TensorType](@Cast(Array("int64_t")) high: CLongPointer, @ByVal size: IntArrayRef, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def randint(@Cast(Array("int64_t")) high: CLongPointer, @ByVal size: IntArrayRef): Tensor[Double, CPU]
	@native @Namespace("at") @ByVal def randint[T, TT <: TensorType](@Cast(Array("int64_t")) high: CLongPointer, @ByVal size: IntArrayRef, generator: Generator, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def randint(@Cast(Array("int64_t")) high: CLongPointer, @ByVal size: IntArrayRef, generator: Generator): Tensor[Double, CPU]
	@native @Namespace("at") @ByVal def randint[T, TT <: TensorType](@Cast(Array("int64_t")) low: CLongPointer, @Cast(Array("int64_t")) high: CLongPointer, @ByVal size: IntArrayRef, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def randint(@Cast(Array("int64_t")) low: CLongPointer, @Cast(Array("int64_t")) high: CLongPointer, @ByVal size: IntArrayRef): Tensor[Double, CPU]
	@native @Namespace("at") @ByVal def randint[T, TT <: TensorType](@Cast(Array("int64_t")) low: CLongPointer, @Cast(Array("int64_t")) high: CLongPointer, @ByVal size: IntArrayRef, generator: Generator, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def randint(@Cast(Array("int64_t")) low: CLongPointer, @Cast(Array("int64_t")) high: CLongPointer, @ByVal size: IntArrayRef, generator: Generator): Tensor[Double, CPU]
	@native @Namespace("at") @ByRef def randint_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Cast(Array("int64_t")) high: CLongPointer, @ByVal size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def randint_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Cast(Array("int64_t")) high: CLongPointer, @ByVal size: IntArrayRef, generator: Generator): Tensor[T, TT]
	@native @Namespace("at") @ByRef def randint_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Cast(Array("int64_t")) low: CLongPointer, @Cast(Array("int64_t")) high: CLongPointer, @ByVal size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def randint_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Cast(Array("int64_t")) low: CLongPointer, @Cast(Array("int64_t")) high: CLongPointer, @ByVal size: IntArrayRef, generator: Generator): Tensor[T, TT]
	@native @Namespace("at") @ByVal def randint_like[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) high: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def randint_like[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) low: CLongPointer, @Cast(Array("int64_t")) high: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def randint_like[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) high: CLongPointer, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def randint_like[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) low: CLongPointer, @Cast(Array("int64_t")) high: CLongPointer, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def randn[T, TT <: TensorType](@ByVal size: IntArrayRef, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def randn(@ByVal size: IntArrayRef): Tensor[Double, CPU]
	@native @Namespace("at") @ByVal def randn[T, TT <: TensorType](@ByVal size: IntArrayRef, generator: Generator, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def randn(@ByVal size: IntArrayRef, generator: Generator): Tensor[Double, CPU]
	@native @Namespace("at") @ByRef def randn_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByVal size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def randn_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByVal size: IntArrayRef, generator: Generator): Tensor[T, TT]
	@native @Namespace("at") @ByVal def randn_like[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def randn_like[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def randperm[T, TT <: TensorType](@Cast(Array("int64_t")) n: CLongPointer, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def randperm(@Cast(Array("int64_t")) n: CLongPointer): Tensor[Double, CPU]
	@native @Namespace("at") @ByVal def randperm[T, TT <: TensorType](@Cast(Array("int64_t")) n: CLongPointer, generator: Generator, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def randperm(@Cast(Array("int64_t")) n: CLongPointer, generator: Generator): Tensor[Double, CPU]
	@native @Namespace("at") @ByRef def randperm_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Cast(Array("int64_t")) n: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def randperm_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Cast(Array("int64_t")) n: CLongPointer, generator: Generator): Tensor[T, TT]
	@native @Namespace("at") @ByRef def range_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByVal start: Scalar[T], @ByVal end: Scalar[T], @ByVal step: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def range_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByVal start: Scalar[T], @ByVal end: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def reciprocal[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def reciprocal_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def reciprocal_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def neg[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def neg_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def neg_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def repeat_interleave[T, TT <: TensorType](@Const @ByRef repeats: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def repeat_interleave[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef repeats: Tensor[T, TT], @Cast(Array("int64_t*")) @C10Optional dim: LongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def repeat_interleave[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef repeats: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def repeat_interleave[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef repeats: Tensor[T, TT], @Cast(Array("int64_t*")) @C10Optional dim: LongBuffer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def repeat_interleave[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef repeats: Tensor[T, TT], @Cast(Array("int64_t*")) @C10Optional dim: Array[Long]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def repeat_interleave[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) repeats: CLongPointer, @Cast(Array("int64_t*")) @C10Optional dim: LongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def repeat_interleave[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) repeats: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def repeat_interleave[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) repeats: CLongPointer, @Cast(Array("int64_t*")) @C10Optional dim: LongBuffer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def repeat_interleave[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) repeats: CLongPointer, @Cast(Array("int64_t*")) @C10Optional dim: Array[Long]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def reshape[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal shape: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _mkldnn_reshape[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal shape: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def round[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def round_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def round_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def rrelu[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal lower: Scalar[T], @ByVal upper: Scalar[T], @Cast(Array("bool")) training: Boolean, generator: Generator): Tensor[T, TT]
	@native @Namespace("at") @ByVal def rrelu[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def rrelu_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @ByVal lower: Scalar[T], @ByVal upper: Scalar[T], @Cast(Array("bool")) training: Boolean, generator: Generator): Tensor[T, TT]
	@native @Namespace("at") @ByRef def rrelu_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def relu[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def relu_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def prelu[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def prelu_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def gelu[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def gelu_backward[T, TT <: TensorType](@Const @ByRef grad: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def hardshrink[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal lambd: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def hardshrink[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def hardshrink_backward[T, TT <: TensorType](@Const @ByRef grad_out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal lambd: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def rsqrt[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def rsqrt_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def rsqrt_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def select[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("int64_t")) index: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def selu[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def selu_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def celu[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def celu[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def celu_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def celu_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def sigmoid[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def sigmoid_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def sigmoid_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def sin[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def sin_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def sin_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def sinh[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def sinh_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def sinh_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def detach[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def detach_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def slice[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("int64_t")) start: CLongPointer, @Cast(Array("int64_t")) end: CLongPointer, @Cast(Array("int64_t")) step: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def slice[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def slogdet[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def smm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef mat2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def softmax[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @C10Optional dtype: ScalarType): Tensor[T, TT]
	@native @Namespace("at") @ByVal def softmax[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _softmax[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) half_to_float: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _softmax_backward_data[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef output: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _sparse_add_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _sparse_add_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _sparse_dense_add_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _sparse_dense_add_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _sparse_div_zerodim_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _sparse_div_scalar_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _sparse_mul_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _sparse_mul_zerodim_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _sparse_mul_scalar_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @StdVector def split[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) split_size: CLongPointer, @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @StdVector def split[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) split_size: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @StdVector def split_with_sizes[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal split_sizes: IntArrayRef, @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @StdVector def split_with_sizes[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal split_sizes: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def squeeze[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def squeeze[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def sspaddmm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef mat1: Tensor[T, TT], @Const @ByRef mat2: Tensor[T, TT], @ByVal beta: Scalar[T], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def sspaddmm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef mat1: Tensor[T, TT], @Const @ByRef mat2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def sspaddmm_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef mat1: Tensor[T, TT], @Const @ByRef mat2: Tensor[T, TT], @ByVal beta: Scalar[T], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def sspaddmm_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef mat1: Tensor[T, TT], @Const @ByRef mat2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def stack[T, TT <: TensorType](@ByVal tensors: TensorList[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def stack[T, TT <: TensorType](@ByVal tensors: TensorList[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def stack_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByVal tensors: TensorList[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def stack_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByVal tensors: TensorList[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def stft[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) n_fft: CLongPointer, @Cast(Array("int64_t*")) @C10Optional hop_length: LongPointer, @Cast(Array("int64_t*")) @C10Optional win_length: LongPointer, @Const @ByRef window: Tensor[T, TT], @Cast(Array("bool")) normalized: Boolean, @Cast(Array("bool")) onesided: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def stft[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) n_fft: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def stft[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) n_fft: CLongPointer, @Cast(Array("int64_t*")) @C10Optional hop_length: LongBuffer, @Cast(Array("int64_t*")) @C10Optional win_length: LongBuffer, @Const @ByRef window: Tensor[T, TT], @Cast(Array("bool")) normalized: Boolean, @Cast(Array("bool")) onesided: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def stft[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) n_fft: CLongPointer, @Cast(Array("int64_t*")) @C10Optional hop_length: Array[Long], @Cast(Array("int64_t*")) @C10Optional win_length: Array[Long], @Const @ByRef window: Tensor[T, TT], @Cast(Array("bool")) normalized: Boolean, @Cast(Array("bool")) onesided: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def sum[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @C10Optional dtype: ScalarType): Tensor[T, TT]
	@native @Namespace("at") @ByVal def sum[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def sum[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef, @Cast(Array("bool")) keepdim: Boolean, @C10Optional dtype: ScalarType): Tensor[T, TT]
	@native @Namespace("at") @ByVal def sum[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def sum_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef, @Cast(Array("bool")) keepdim: Boolean, @C10Optional dtype: ScalarType): Tensor[T, TT]
	@native @Namespace("at") @ByRef def sum_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def sqrt[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def sqrt_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def sqrt_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def std[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) unbiased: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def std[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def std[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef, @Cast(Array("bool")) unbiased: Boolean, @Cast(Array("bool")) keepdim: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def std[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def std_mean[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) unbiased: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def std_mean[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def std_mean[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef, @Cast(Array("bool")) unbiased: Boolean, @Cast(Array("bool")) keepdim: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def std_mean[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByRef def std_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef, @Cast(Array("bool")) unbiased: Boolean, @Cast(Array("bool")) keepdim: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def std_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def prod[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @C10Optional dtype: ScalarType): Tensor[T, TT]
	@native @Namespace("at") @ByVal def prod[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def prod[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) keepdim: Boolean, @C10Optional dtype: ScalarType): Tensor[T, TT]
	@native @Namespace("at") @ByVal def prod[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def prod_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) keepdim: Boolean, @C10Optional dtype: ScalarType): Tensor[T, TT]
	@native @Namespace("at") @ByRef def prod_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def t[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def tan[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def tan_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def tan_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def tanh[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def tanh_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def tanh_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def tensordot[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT], @ByVal dims_self: IntArrayRef, @ByVal dims_other: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def threshold[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal threshold: Scalar[T], @ByVal value: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def threshold_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @ByVal threshold: Scalar[T], @ByVal value: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def threshold_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal threshold: Scalar[T], @ByVal value: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def threshold_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal threshold: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def transpose[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim0: CLongPointer, @Cast(Array("int64_t")) dim1: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _mkldnn_transpose[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim0: CLongPointer, @Cast(Array("int64_t")) dim1: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _mkldnn_transpose_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim0: CLongPointer, @Cast(Array("int64_t")) dim1: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def one_hot[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) num_classes: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def one_hot[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def flip[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal dims: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def roll[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal shifts: IntArrayRef, @ByVal dims: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def roll[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal shifts: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def rot90[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) k: CLongPointer, @ByVal dims: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def rot90[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def trapz[T, TT <: TensorType](@Const @ByRef y: Tensor[T, TT], @Const @ByRef x: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def trapz[T, TT <: TensorType](@Const @ByRef y: Tensor[T, TT], @Const @ByRef x: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def trapz[T, TT <: TensorType](@Const @ByRef y: Tensor[T, TT], dx: Double, @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def trapz[T, TT <: TensorType](@Const @ByRef y: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _trilinear[T, TT <: TensorType](@Const @ByRef i1: Tensor[T, TT], @Const @ByRef i2: Tensor[T, TT], @Const @ByRef i3: Tensor[T, TT], @ByVal expand1: IntArrayRef, @ByVal expand2: IntArrayRef, @ByVal expand3: IntArrayRef, @ByVal sumdim: IntArrayRef, @Cast(Array("int64_t")) unroll_dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _trilinear[T, TT <: TensorType](@Const @ByRef i1: Tensor[T, TT], @Const @ByRef i2: Tensor[T, TT], @Const @ByRef i3: Tensor[T, TT], @ByVal expand1: IntArrayRef, @ByVal expand2: IntArrayRef, @ByVal expand3: IntArrayRef, @ByVal sumdim: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def triplet_margin_loss[T, TT <: TensorType](@Const @ByRef anchor: Tensor[T, TT], @Const @ByRef positive: Tensor[T, TT], @Const @ByRef negative: Tensor[T, TT], margin: Double, p: Double, eps: Double, @Cast(Array("bool")) swap: Boolean, @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def triplet_margin_loss[T, TT <: TensorType](@Const @ByRef anchor: Tensor[T, TT], @Const @ByRef positive: Tensor[T, TT], @Const @ByRef negative: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def trunc[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def trunc_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def trunc_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @Cast(Array("bool")) def _has_same_tensorimpl_type[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Boolean
	@native @Namespace("at") @ByVal def _unique[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) sorted: Boolean, @Cast(Array("bool")) return_inverse: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def _unique[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def unique_dim[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) sorted: Boolean, @Cast(Array("bool")) return_inverse: Boolean, @Cast(Array("bool")) return_counts: Boolean): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def unique_dim[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def unique_consecutive[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) return_inverse: Boolean, @Cast(Array("bool")) return_counts: Boolean, @Cast(Array("int64_t*")) @C10Optional dim: LongPointer): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def unique_consecutive[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def unique_consecutive[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) return_inverse: Boolean, @Cast(Array("bool")) return_counts: Boolean, @Cast(Array("int64_t*")) @C10Optional dim: LongBuffer): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def unique_consecutive[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) return_inverse: Boolean, @Cast(Array("bool")) return_counts: Boolean, @Cast(Array("int64_t*")) @C10Optional dim: Array[Long]): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def unique_dim_consecutive[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) return_inverse: Boolean, @Cast(Array("bool")) return_counts: Boolean): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def unique_dim_consecutive[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def _unique2[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) sorted: Boolean, @Cast(Array("bool")) return_inverse: Boolean, @Cast(Array("bool")) return_counts: Boolean): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def _unique2[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def _unsafe_view[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def unsqueeze[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def `var`[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) unbiased: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def `var`[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def `var`[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef, @Cast(Array("bool")) unbiased: Boolean, @Cast(Array("bool")) keepdim: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def `var`[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def var_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef, @Cast(Array("bool")) unbiased: Boolean, @Cast(Array("bool")) keepdim: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def var_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def var_mean[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) unbiased: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def var_mean[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def var_mean[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef, @Cast(Array("bool")) unbiased: Boolean, @Cast(Array("bool")) keepdim: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def var_mean[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def where[T, TT <: TensorType](@Const @ByRef condition: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @StdVector def where[T, TT <: TensorType](@Const @ByRef condition: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _s_where[T, TT <: TensorType](@Const @ByRef condition: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def norm_except_dim[T, TT <: TensorType](@Const @ByRef v: Tensor[T, TT], @Cast(Array("int64_t")) pow: CLongPointer, @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def norm_except_dim[T, TT <: TensorType](@Const @ByRef v: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _weight_norm[T, TT <: TensorType](@Const @ByRef v: Tensor[T, TT], @Const @ByRef g: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _weight_norm[T, TT <: TensorType](@Const @ByRef v: Tensor[T, TT], @Const @ByRef g: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _weight_norm_cuda_interface[T, TT <: TensorType](@Const @ByRef v: Tensor[T, TT], @Const @ByRef g: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def _weight_norm_cuda_interface[T, TT <: TensorType](@Const @ByRef v: Tensor[T, TT], @Const @ByRef g: Tensor[T, TT]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def _weight_norm_cuda_interface_backward[T, TT <: TensorType](@Const @ByRef grad_w: Tensor[T, TT], @Const @ByRef saved_v: Tensor[T, TT], @Const @ByRef saved_g: Tensor[T, TT], @Const @ByRef saved_norms: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def _weight_norm_differentiable_backward[T, TT <: TensorType](@Const @ByRef grad_w: Tensor[T, TT], @Const @ByRef saved_v: Tensor[T, TT], @Const @ByRef saved_g: Tensor[T, TT], @Const @ByRef saved_norms: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def zeros[T, TT <: TensorType](@ByVal size: IntArrayRef, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def zeros(@ByVal size: IntArrayRef): Tensor[Double, CPU]
	@native @Namespace("at") @ByRef def zeros_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByVal size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def zeros_like[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def zeros_like[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _standard_gamma_grad[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef output: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _standard_gamma[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], generator: Generator): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _standard_gamma[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _dirichlet_grad[T, TT <: TensorType](@Const @ByRef x: Tensor[T, TT], @Const @ByRef alpha: Tensor[T, TT], @Const @ByRef total: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _sample_dirichlet[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], generator: Generator): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _sample_dirichlet[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def poisson[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], generator: Generator): Tensor[T, TT]
	@native @Namespace("at") @ByVal def poisson[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def native_norm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal p: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def native_norm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _sparse_sum[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _sparse_sum[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal dtype: ScalarType): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _sparse_sum[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _sparse_sum[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef, @ByVal dtype: ScalarType): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _sparse_sum_backward[T, TT <: TensorType](@Const @ByRef grad: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def norm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @C10Optional p: Scalar[T], @ByVal dtype: ScalarType): Tensor[T, TT]
	@native @Namespace("at") @ByVal def norm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal p: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def norm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def norm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @C10Optional p: Scalar[T], @ByVal dim: IntArrayRef, @Cast(Array("bool")) keepdim: Boolean, @ByVal dtype: ScalarType): Tensor[T, TT]
	@native @Namespace("at") @ByVal def norm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @C10Optional p: Scalar[T], @ByVal dim: IntArrayRef, @Cast(Array("bool")) keepdim: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def norm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @C10Optional p: Scalar[T], @ByVal dim: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def norm_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @C10Optional p: Scalar[T], @ByVal dim: IntArrayRef, @Cast(Array("bool")) keepdim: Boolean, @ByVal dtype: ScalarType): Tensor[T, TT]
	@native @Namespace("at") @ByRef def norm_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @C10Optional p: Scalar[T], @ByVal dim: IntArrayRef, @Cast(Array("bool")) keepdim: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def norm_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @C10Optional p: Scalar[T], @ByVal dim: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def frobenius_norm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def frobenius_norm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef, @Cast(Array("bool")) keepdim: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def frobenius_norm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def frobenius_norm_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef, @Cast(Array("bool")) keepdim: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def frobenius_norm_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def nuclear_norm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) keepdim: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def nuclear_norm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def nuclear_norm_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) keepdim: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def nuclear_norm_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def nuclear_norm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef, @Cast(Array("bool")) keepdim: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def nuclear_norm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def nuclear_norm_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef, @Cast(Array("bool")) keepdim: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def nuclear_norm_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal dim: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def clone[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def resize_as_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @Const @ByRef the_template: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def pow_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal exponent: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def pow[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal exponent: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def zero_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def sub_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def sub_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def sub[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def sub[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def sub[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def sub[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def rsub[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def rsub[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def rsub[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def rsub[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def s_native_addmm_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef mat1: Tensor[T, TT], @Const @ByRef mat2: Tensor[T, TT], @ByVal beta: Scalar[T], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def s_native_addmm_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef mat1: Tensor[T, TT], @Const @ByRef mat2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def s_native_addmm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef mat1: Tensor[T, TT], @Const @ByRef mat2: Tensor[T, TT], @ByVal beta: Scalar[T], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def s_native_addmm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef mat1: Tensor[T, TT], @Const @ByRef mat2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def s_native_addmm_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @Const @ByRef mat1: Tensor[T, TT], @Const @ByRef mat2: Tensor[T, TT], @ByVal beta: Scalar[T], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def s_native_addmm_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @Const @ByRef mat1: Tensor[T, TT], @Const @ByRef mat2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _sparse_addmm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef sparse: Tensor[T, TT], @Const @ByRef dense: Tensor[T, TT], @ByVal beta: Scalar[T], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _sparse_addmm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef sparse: Tensor[T, TT], @Const @ByRef dense: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def addmm_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef mat1: Tensor[T, TT], @Const @ByRef mat2: Tensor[T, TT], @ByVal beta: Scalar[T], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def addmm_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef mat1: Tensor[T, TT], @Const @ByRef mat2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def addmm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef mat1: Tensor[T, TT], @Const @ByRef mat2: Tensor[T, TT], @ByVal beta: Scalar[T], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def addmm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef mat1: Tensor[T, TT], @Const @ByRef mat2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def sparse_coo_tensor[T, TT <: TensorType](@ByVal size: IntArrayRef, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def sparse_coo_tensor[TT <: TensorType, T](@Const @ByRef indices: Tensor[Long, TT], @Const @ByRef values: Tensor[T, TT], @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def sparse_coo_tensor[TT <: TensorType, T](@Const @ByRef indices: Tensor[Long, TT], @Const @ByRef values: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def sparse_coo_tensor[TT <: TensorType, T](@Const @ByRef indices: Tensor[Long, TT], @Const @ByRef values: Tensor[T, TT], @ByVal size: IntArrayRef, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def sparse_coo_tensor[TT <: TensorType, T](@Const @ByRef indices: Tensor[Long, TT], @Const @ByRef values: Tensor[T, TT], @ByVal size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _sparse_coo_tensor_unsafe[TT <: TensorType, T](@Const @ByRef indices: Tensor[Long, TT], @Const @ByRef values: Tensor[T, TT], @ByVal size: IntArrayRef, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _sparse_coo_tensor_unsafe[TT <: TensorType, T](@Const @ByRef indices: Tensor[Long, TT], @Const @ByRef values: Tensor[T, TT], @ByVal size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _sparse_coo_tensor_with_dims[T, TT <: TensorType](@Cast(Array("int64_t")) sparse_dim: CLongPointer, @Cast(Array("int64_t")) dense_dim: CLongPointer, @ByVal size: IntArrayRef, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _sparse_coo_tensor_with_dims_and_tensors[T, TT <: TensorType](@Cast(Array("int64_t")) sparse_dim: CLongPointer, @Cast(Array("int64_t")) dense_dim: CLongPointer, @ByVal size: IntArrayRef, @Const @ByRef indices: Tensor[Long, TT], @Const @ByRef values: Tensor[T, TT], @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def to_dense_backward[T, TT <: TensorType](@Const @ByRef grad: Tensor[T, TT], @Const @ByRef input: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def hspmm_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef mat1: Tensor[T, TT], @Const @ByRef mat2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def hspmm[T, TT <: TensorType](@Const @ByRef mat1: Tensor[T, TT], @Const @ByRef mat2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def copy_sparse_to_sparse_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @Const @ByRef src: Tensor[T, TT], @Cast(Array("bool")) non_blocking: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def copy_sparse_to_sparse_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @Const @ByRef src: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @StdVector def unbind[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @StdVector def unbind[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def mkldnn_reorder_conv2d_weight[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("int64_t")) groups: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def mkldnn_reorder_conv2d_weight[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def to_mkldnn_backward[T, TT <: TensorType](@Const @ByRef grad: Tensor[T, TT], @Const @ByRef input: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def quantize_linear[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], scale: Double, @Cast(Array("int64_t")) zero_point: CLongPointer, @ByVal dtype: ScalarType): Tensor[T, TT]
	@native @Namespace("at") @ByVal def quantize_linear_per_channel[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef scales: Tensor[T, TT], @Const @ByRef zero_points: Tensor[T, TT], @ByVal axis: IntArrayRef, @ByVal dtype: ScalarType): Tensor[T, TT]
	@native @Namespace("at") @ByVal def dequantize[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _dequantize_linear[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], scale: Double, @Cast(Array("int64_t")) zero_point: CLongPointer, @ByVal dtype: ScalarType): Tensor[T, TT]
	@native @Namespace("at") def q_scale[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Double
	@native @Namespace("at") @ByVal def int_repr[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _per_tensor_affine_qtensor[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], scale: Double, @Cast(Array("int64_t")) zero_point: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @StdVector def meshgrid[T, TT <: TensorType](@ByVal tensors: TensorList[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cartesian_prod[T, TT <: TensorType](@ByVal tensors: TensorList[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def combinations[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) r: CLongPointer, @Cast(Array("bool")) with_replacement: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def combinations[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _local_scalar_dense[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Scalar[T]
	@native @Namespace("at") @ByVal def _thnn_fused_lstm_cell[T, TT <: TensorType](@Const @ByRef input_gates: Tensor[T, TT], @Const @ByRef hidden_gates: Tensor[T, TT], @Const @ByRef cx: Tensor[T, TT], @Const @ByRef input_bias: Tensor[T, TT], @Const @ByRef hidden_bias: Tensor[T, TT]): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def _thnn_fused_lstm_cell[T, TT <: TensorType](@Const @ByRef input_gates: Tensor[T, TT], @Const @ByRef hidden_gates: Tensor[T, TT], @Const @ByRef cx: Tensor[T, TT]): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def _thnn_fused_lstm_cell_backward[T, TT <: TensorType](@Const @ByRef grad_hy: Tensor[T, TT], @Const @ByRef grad_cy: Tensor[T, TT], @Const @ByRef cx: Tensor[T, TT], @Const @ByRef cy: Tensor[T, TT], @Const @ByRef workspace: Tensor[T, TT], @Cast(Array("bool")) has_bias: Boolean): TensorTuple5[T,TT]
	@native @Namespace("at") @ByVal def _thnn_fused_gru_cell[T, TT <: TensorType](@Const @ByRef input_gates: Tensor[T, TT], @Const @ByRef hidden_gates: Tensor[T, TT], @Const @ByRef hx: Tensor[T, TT], @Const @ByRef input_bias: Tensor[T, TT], @Const @ByRef hidden_bias: Tensor[T, TT]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def _thnn_fused_gru_cell[T, TT <: TensorType](@Const @ByRef input_gates: Tensor[T, TT], @Const @ByRef hidden_gates: Tensor[T, TT], @Const @ByRef hx: Tensor[T, TT]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def _thnn_fused_gru_cell_backward[T, TT <: TensorType](@Const @ByRef grad_hy: Tensor[T, TT], @Const @ByRef workspace: Tensor[T, TT], @Cast(Array("bool")) has_bias: Boolean): TensorTuple5[T,TT]
	@native @Namespace("at") @ByVal def lstm[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @ByVal hx: TensorList[T, TT], @ByVal params: TensorList[T, TT], @Cast(Array("bool")) has_biases: Boolean, @Cast(Array("int64_t")) num_layers: CLongPointer, dropout: Double, @Cast(Array("bool")) train: Boolean, @Cast(Array("bool")) bidirectional: Boolean, @Cast(Array("bool")) batch_first: Boolean): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def lstm[T, TT <: TensorType](@Const @ByRef data: Tensor[T, TT], @Const @ByRef batch_sizes: Tensor[T, TT], @ByVal hx: TensorList[T, TT], @ByVal params: TensorList[T, TT], @Cast(Array("bool")) has_biases: Boolean, @Cast(Array("int64_t")) num_layers: CLongPointer, dropout: Double, @Cast(Array("bool")) train: Boolean, @Cast(Array("bool")) bidirectional: Boolean): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def gru[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef hx: Tensor[T, TT], @ByVal params: TensorList[T, TT], @Cast(Array("bool")) has_biases: Boolean, @Cast(Array("int64_t")) num_layers: CLongPointer, dropout: Double, @Cast(Array("bool")) train: Boolean, @Cast(Array("bool")) bidirectional: Boolean, @Cast(Array("bool")) batch_first: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def gru[T, TT <: TensorType](@Const @ByRef data: Tensor[T, TT], @Const @ByRef batch_sizes: Tensor[T, TT], @Const @ByRef hx: Tensor[T, TT], @ByVal params: TensorList[T, TT], @Cast(Array("bool")) has_biases: Boolean, @Cast(Array("int64_t")) num_layers: CLongPointer, dropout: Double, @Cast(Array("bool")) train: Boolean, @Cast(Array("bool")) bidirectional: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def rnn_tanh[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef hx: Tensor[T, TT], @ByVal params: TensorList[T, TT], @Cast(Array("bool")) has_biases: Boolean, @Cast(Array("int64_t")) num_layers: CLongPointer, dropout: Double, @Cast(Array("bool")) train: Boolean, @Cast(Array("bool")) bidirectional: Boolean, @Cast(Array("bool")) batch_first: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def rnn_tanh[T, TT <: TensorType](@Const @ByRef data: Tensor[T, TT], @Const @ByRef batch_sizes: Tensor[T, TT], @Const @ByRef hx: Tensor[T, TT], @ByVal params: TensorList[T, TT], @Cast(Array("bool")) has_biases: Boolean, @Cast(Array("int64_t")) num_layers: CLongPointer, dropout: Double, @Cast(Array("bool")) train: Boolean, @Cast(Array("bool")) bidirectional: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def rnn_relu[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef hx: Tensor[T, TT], @ByVal params: TensorList[T, TT], @Cast(Array("bool")) has_biases: Boolean, @Cast(Array("int64_t")) num_layers: CLongPointer, dropout: Double, @Cast(Array("bool")) train: Boolean, @Cast(Array("bool")) bidirectional: Boolean, @Cast(Array("bool")) batch_first: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def rnn_relu[T, TT <: TensorType](@Const @ByRef data: Tensor[T, TT], @Const @ByRef batch_sizes: Tensor[T, TT], @Const @ByRef hx: Tensor[T, TT], @ByVal params: TensorList[T, TT], @Cast(Array("bool")) has_biases: Boolean, @Cast(Array("int64_t")) num_layers: CLongPointer, dropout: Double, @Cast(Array("bool")) train: Boolean, @Cast(Array("bool")) bidirectional: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def lstm_cell[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @ByVal hx: TensorList[T, TT], @Const @ByRef w_ih: Tensor[T, TT], @Const @ByRef w_hh: Tensor[T, TT], @Const @ByRef b_ih: Tensor[T, TT], @Const @ByRef b_hh: Tensor[T, TT]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def lstm_cell[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @ByVal hx: TensorList[T, TT], @Const @ByRef w_ih: Tensor[T, TT], @Const @ByRef w_hh: Tensor[T, TT]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def gru_cell[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef hx: Tensor[T, TT], @Const @ByRef w_ih: Tensor[T, TT], @Const @ByRef w_hh: Tensor[T, TT], @Const @ByRef b_ih: Tensor[T, TT], @Const @ByRef b_hh: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def gru_cell[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef hx: Tensor[T, TT], @Const @ByRef w_ih: Tensor[T, TT], @Const @ByRef w_hh: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def rnn_tanh_cell[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef hx: Tensor[T, TT], @Const @ByRef w_ih: Tensor[T, TT], @Const @ByRef w_hh: Tensor[T, TT], @Const @ByRef b_ih: Tensor[T, TT], @Const @ByRef b_hh: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def rnn_tanh_cell[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef hx: Tensor[T, TT], @Const @ByRef w_ih: Tensor[T, TT], @Const @ByRef w_hh: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def rnn_relu_cell[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef hx: Tensor[T, TT], @Const @ByRef w_ih: Tensor[T, TT], @Const @ByRef w_hh: Tensor[T, TT], @Const @ByRef b_ih: Tensor[T, TT], @Const @ByRef b_hh: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def rnn_relu_cell[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef hx: Tensor[T, TT], @Const @ByRef w_ih: Tensor[T, TT], @Const @ByRef w_hh: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def quantized_lstm[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @ByVal hx: TensorList[T, TT], @ByVal params: TensorList[T, TT], @Cast(Array("bool")) has_biases: Boolean, @Cast(Array("int64_t")) num_layers: CLongPointer, dropout: Double, @Cast(Array("bool")) train: Boolean, @Cast(Array("bool")) bidirectional: Boolean, @Cast(Array("bool")) batch_first: Boolean): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def quantized_lstm_cell[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @ByVal hx: TensorList[T, TT], @Const @ByRef w_ih: Tensor[T, TT], @Const @ByRef w_hh: Tensor[T, TT], @Const @ByRef b_ih: Tensor[T, TT], @Const @ByRef b_hh: Tensor[T, TT], @Const @ByRef packed_ih: Tensor[T, TT], @Const @ByRef packed_hh: Tensor[T, TT], @Const @ByRef col_offsets_ih: Tensor[T, TT], @Const @ByRef col_offsets_hh: Tensor[T, TT], @ByVal scale_ih: Scalar[T], @ByVal scale_hh: Scalar[T], @ByVal zero_point_ih: Scalar[T], @ByVal zero_point_hh: Scalar[T]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def quantized_gru_cell[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef hx: Tensor[T, TT], @Const @ByRef w_ih: Tensor[T, TT], @Const @ByRef w_hh: Tensor[T, TT], @Const @ByRef b_ih: Tensor[T, TT], @Const @ByRef b_hh: Tensor[T, TT], @Const @ByRef packed_ih: Tensor[T, TT], @Const @ByRef packed_hh: Tensor[T, TT], @Const @ByRef col_offsets_ih: Tensor[T, TT], @Const @ByRef col_offsets_hh: Tensor[T, TT], @ByVal scale_ih: Scalar[T], @ByVal scale_hh: Scalar[T], @ByVal zero_point_ih: Scalar[T], @ByVal zero_point_hh: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def quantized_rnn_relu_cell[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef hx: Tensor[T, TT], @Const @ByRef w_ih: Tensor[T, TT], @Const @ByRef w_hh: Tensor[T, TT], @Const @ByRef b_ih: Tensor[T, TT], @Const @ByRef b_hh: Tensor[T, TT], @Const @ByRef packed_ih: Tensor[T, TT], @Const @ByRef packed_hh: Tensor[T, TT], @Const @ByRef col_offsets_ih: Tensor[T, TT], @Const @ByRef col_offsets_hh: Tensor[T, TT], @ByVal scale_ih: Scalar[T], @ByVal scale_hh: Scalar[T], @ByVal zero_point_ih: Scalar[T], @ByVal zero_point_hh: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def quantized_rnn_tanh_cell[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef hx: Tensor[T, TT], @Const @ByRef w_ih: Tensor[T, TT], @Const @ByRef w_hh: Tensor[T, TT], @Const @ByRef b_ih: Tensor[T, TT], @Const @ByRef b_hh: Tensor[T, TT], @Const @ByRef packed_ih: Tensor[T, TT], @Const @ByRef packed_hh: Tensor[T, TT], @Const @ByRef col_offsets_ih: Tensor[T, TT], @Const @ByRef col_offsets_hh: Tensor[T, TT], @ByVal scale_ih: Scalar[T], @ByVal scale_hh: Scalar[T], @ByVal zero_point_ih: Scalar[T], @ByVal zero_point_hh: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _pack_padded_sequence[T, TT <: TensorType](@Const @ByRef input: Tensor[T, TT], @Const @ByRef lengths: Tensor[T, TT], @Cast(Array("bool")) batch_first: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def _pack_padded_sequence_backward[T, TT <: TensorType](@Const @ByRef grad: Tensor[T, TT], @ByVal input_size: IntArrayRef, @Const @ByRef batch_sizes: Tensor[T, TT], @Cast(Array("bool")) batch_first: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _pad_packed_sequence[T, TT <: TensorType](@Const @ByRef data: Tensor[T, TT], @Const @ByRef batch_sizes: Tensor[T, TT], @Cast(Array("bool")) batch_first: Boolean, @ByVal padding_value: Scalar[T], @Cast(Array("int64_t")) total_length: CLongPointer): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def masked_fill[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef mask: Tensor[Byte, TT], @ByVal value: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def masked_fill[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef mask: Tensor[Byte, TT], @Const @ByRef value: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def masked_scatter[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef mask: Tensor[Byte, TT], @Const @ByRef source: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def index_add[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Const @ByRef index: Tensor[Long, TT], @Const @ByRef source: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def index_fill[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Const @ByRef index: Tensor[Long, TT], @ByVal value: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def index_fill[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Const @ByRef index: Tensor[Long, TT], @Const @ByRef value: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def scatter[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Const @ByRef index: Tensor[Long, TT], @Const @ByRef src: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def scatter[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Const @ByRef index: Tensor[Long, TT], @ByVal value: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def scatter_add[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Const @ByRef index: Tensor[Long, TT], @Const @ByRef src: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def __and__[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def __and__[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def __or__[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def __or__[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def __xor__[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def __xor__[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def __lshift__[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def __lshift__[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def __rshift__[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def __rshift__[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def addbmm_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef batch1: Tensor[T, TT], @Const @ByRef batch2: Tensor[T, TT], @ByVal beta: Scalar[T], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def addbmm_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef batch1: Tensor[T, TT], @Const @ByRef batch2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def addbmm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef batch1: Tensor[T, TT], @Const @ByRef batch2: Tensor[T, TT], @ByVal beta: Scalar[T], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def addbmm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef batch1: Tensor[T, TT], @Const @ByRef batch2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def diag_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) diagonal: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def diag_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def diag[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) diagonal: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def diag[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def cross_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT], @Cast(Array("int64_t*")) @C10Optional dim: LongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def cross_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def cross_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT], @Cast(Array("int64_t*")) @C10Optional dim: LongBuffer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def cross_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT], @Cast(Array("int64_t*")) @C10Optional dim: Array[Long]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cross[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT], @Cast(Array("int64_t*")) @C10Optional dim: LongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cross[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cross[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT], @Cast(Array("int64_t*")) @C10Optional dim: LongBuffer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cross[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT], @Cast(Array("int64_t*")) @C10Optional dim: Array[Long]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def triu_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) diagonal: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def triu_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def triu[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) diagonal: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def triu[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def tril_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) diagonal: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def tril_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def tril[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) diagonal: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def tril[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def tril_indices[T, TT <: TensorType](@Cast(Array("int64_t")) row: CLongPointer, @Cast(Array("int64_t")) col: CLongPointer, @Cast(Array("int64_t")) offset: CLongPointer, @Const @ByRef options: TensorOptions[T, TT]): Tensor[Long, TT]
	@native @Namespace("at") @ByVal def tril_indices(@Cast(Array("int64_t")) row: CLongPointer, @Cast(Array("int64_t")) col: CLongPointer): Tensor[Long, CPU]
	@native @Namespace("at") @ByVal def triu_indices[T, TT <: TensorType](@Cast(Array("int64_t")) row: CLongPointer, @Cast(Array("int64_t")) col: CLongPointer, @Cast(Array("int64_t")) offset: CLongPointer, @Const @ByRef options: TensorOptions[T, TT]): Tensor[Long, TT]
	@native @Namespace("at") @ByVal def triu_indices(@Cast(Array("int64_t")) row: CLongPointer, @Cast(Array("int64_t")) col: CLongPointer): Tensor[Long, CPU]
	@native @Namespace("at") @ByVal def trace[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def ne_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def ne[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def ne_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def ne[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def eq_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def eq[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def eq_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def eq[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def ge_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def ge[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def ge_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def ge[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def le_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def le[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def le_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def le[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def gt_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def gt[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def gt_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def gt[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def lt_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def lt[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def lt_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def lt[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def take_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef index: Tensor[Long, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def take[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef index: Tensor[Long, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def index_select_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Const @ByRef index: Tensor[Long, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def index_select[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Const @ByRef index: Tensor[Long, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def masked_select_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef mask: Tensor[Byte, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def masked_select[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef mask: Tensor[Byte, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def nonzero_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def nonzero[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @StdVector def nonzero_numpy[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def gather_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Const @ByRef index: Tensor[Long, TT], @Cast(Array("bool")) sparse_grad: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def gather_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Const @ByRef index: Tensor[Long, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def gather[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Const @ByRef index: Tensor[Long, TT], @Cast(Array("bool")) sparse_grad: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def gather[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Const @ByRef index: Tensor[Long, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _gather_sparse_backward[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Const @ByRef index: Tensor[Long, TT], @Const @ByRef grad: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def addcmul_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef tensor1: Tensor[T, TT], @Const @ByRef tensor2: Tensor[T, TT], @ByVal value: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def addcmul_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef tensor1: Tensor[T, TT], @Const @ByRef tensor2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def addcmul[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef tensor1: Tensor[T, TT], @Const @ByRef tensor2: Tensor[T, TT], @ByVal value: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def addcmul[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef tensor1: Tensor[T, TT], @Const @ByRef tensor2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def addcdiv_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef tensor1: Tensor[T, TT], @Const @ByRef tensor2: Tensor[T, TT], @ByVal value: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def addcdiv_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef tensor1: Tensor[T, TT], @Const @ByRef tensor2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def addcdiv[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef tensor1: Tensor[T, TT], @Const @ByRef tensor2: Tensor[T, TT], @ByVal value: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def addcdiv[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef tensor1: Tensor[T, TT], @Const @ByRef tensor2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def gels_out[T, TT <: TensorType](@ByRef X: Tensor[T, TT], @ByRef qr: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef A: Tensor[T, TT]): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def gels[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef A: Tensor[T, TT]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def triangular_solve_out[T, TT <: TensorType](@ByRef X: Tensor[T, TT], @ByRef M: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef A: Tensor[T, TT], @Cast(Array("bool")) upper: Boolean, @Cast(Array("bool")) transpose: Boolean, @Cast(Array("bool")) unitriangular: Boolean): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def triangular_solve_out[T, TT <: TensorType](@ByRef X: Tensor[T, TT], @ByRef M: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef A: Tensor[T, TT]): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def triangular_solve[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef A: Tensor[T, TT], @Cast(Array("bool")) upper: Boolean, @Cast(Array("bool")) transpose: Boolean, @Cast(Array("bool")) unitriangular: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def triangular_solve[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef A: Tensor[T, TT]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def _triangular_solve_helper[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef A: Tensor[T, TT], @Cast(Array("bool")) upper: Boolean, @Cast(Array("bool")) transpose: Boolean, @Cast(Array("bool")) unitriangular: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def symeig_out[T, TT <: TensorType](@ByRef e: Tensor[T, TT], @ByRef V: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) eigenvectors: Boolean, @Cast(Array("bool")) upper: Boolean): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def symeig_out[T, TT <: TensorType](@ByRef e: Tensor[T, TT], @ByRef V: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def symeig[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) eigenvectors: Boolean, @Cast(Array("bool")) upper: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def symeig[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def _symeig_helper[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) eigenvectors: Boolean, @Cast(Array("bool")) upper: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def eig_out[T, TT <: TensorType](@ByRef e: Tensor[T, TT], @ByRef v: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) eigenvectors: Boolean): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def eig_out[T, TT <: TensorType](@ByRef e: Tensor[T, TT], @ByRef v: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def eig[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) eigenvectors: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def eig[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def svd_out[T, TT <: TensorType](@ByRef U: Tensor[T, TT], @ByRef S: Tensor[T, TT], @ByRef V: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) some: Boolean, @Cast(Array("bool")) compute_uv: Boolean): TensorRefTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def svd_out[T, TT <: TensorType](@ByRef U: Tensor[T, TT], @ByRef S: Tensor[T, TT], @ByRef V: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): TensorRefTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def svd[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) some: Boolean, @Cast(Array("bool")) compute_uv: Boolean): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def svd[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByRef def cholesky_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) upper: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def cholesky_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cholesky[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) upper: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cholesky[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _cholesky_helper[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) upper: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def cholesky_solve_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef input2: Tensor[T, TT], @Cast(Array("bool")) upper: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def cholesky_solve_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef input2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cholesky_solve[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef input2: Tensor[T, TT], @Cast(Array("bool")) upper: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cholesky_solve[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef input2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _cholesky_solve_helper[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef A: Tensor[T, TT], @Cast(Array("bool")) upper: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def solve[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef A: Tensor[T, TT]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def solve_out[T, TT <: TensorType](@ByRef solution: Tensor[T, TT], @ByRef lu: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef A: Tensor[T, TT]): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def _solve_helper[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef A: Tensor[T, TT]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByRef def cholesky_inverse_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) upper: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def cholesky_inverse_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cholesky_inverse[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) upper: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def cholesky_inverse[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def pstrf_out[T, TT <: TensorType](@ByRef u: Tensor[T, TT], @ByRef pivot: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) upper: Boolean, @ByVal tol: Scalar[T]): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def pstrf_out[T, TT <: TensorType](@ByRef u: Tensor[T, TT], @ByRef pivot: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def pstrf[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) upper: Boolean, @ByVal tol: Scalar[T]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def pstrf[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def qr_out[T, TT <: TensorType](@ByRef Q: Tensor[T, TT], @ByRef R: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) some: Boolean): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def qr_out[T, TT <: TensorType](@ByRef Q: Tensor[T, TT], @ByRef R: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def qr[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) some: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def qr[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def _qr_helper[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) some: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def geqrf_out[T, TT <: TensorType](@ByRef a: Tensor[T, TT], @ByRef tau: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def geqrf[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByRef def orgqr_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef input2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def orgqr[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef input2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def ormqr_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef input2: Tensor[T, TT], @Const @ByRef input3: Tensor[T, TT], @Cast(Array("bool")) left: Boolean, @Cast(Array("bool")) transpose: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def ormqr_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef input2: Tensor[T, TT], @Const @ByRef input3: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def ormqr[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef input2: Tensor[T, TT], @Const @ByRef input3: Tensor[T, TT], @Cast(Array("bool")) left: Boolean, @Cast(Array("bool")) transpose: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def ormqr[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef input2: Tensor[T, TT], @Const @ByRef input3: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _lu_with_info[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) pivot: Boolean, @Cast(Array("bool")) check_errors: Boolean): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def _lu_with_info[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByRef def lu_solve_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef LU_data: Tensor[T, TT], @Const @ByRef LU_pivots: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def lu_solve[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef LU_data: Tensor[T, TT], @Const @ByRef LU_pivots: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def multinomial_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) num_samples: CLongPointer, @Cast(Array("bool")) replacement: Boolean, generator: Generator): Tensor[T, TT]
	@native @Namespace("at") @ByRef def multinomial_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) num_samples: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def multinomial[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) num_samples: CLongPointer, @Cast(Array("bool")) replacement: Boolean, generator: Generator): Tensor[T, TT]
	@native @Namespace("at") @ByVal def multinomial[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) num_samples: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _multinomial_alias_setup[T, TT <: TensorType](@Const @ByRef probs: Tensor[T, TT]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def _multinomial_alias_draw[T, TT <: TensorType](@Const @ByRef J: Tensor[T, TT], @Const @ByRef q: Tensor[T, TT], @Cast(Array("int64_t")) num_samples: CLongPointer, generator: Generator): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _multinomial_alias_draw[T, TT <: TensorType](@Const @ByRef J: Tensor[T, TT], @Const @ByRef q: Tensor[T, TT], @Cast(Array("int64_t")) num_samples: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def lgamma_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def lgamma[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def digamma_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def digamma[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def polygamma_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Cast(Array("int64_t")) n: CLongPointer, @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def polygamma[T, TT <: TensorType](@Cast(Array("int64_t")) n: CLongPointer, @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def erfinv_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def erfinv[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def dist[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT], @ByVal p: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def dist[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def atan2_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def atan2[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def lerp_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef end: Tensor[T, TT], @ByVal weight: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def lerp_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef end: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def lerp[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef end: Tensor[T, TT], @ByVal weight: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def lerp[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef end: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def histc_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) bins: CLongPointer, @ByVal min: Scalar[T], @ByVal max: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def histc_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def histc[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) bins: CLongPointer, @ByVal min: Scalar[T], @ByVal max: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def histc[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def sign_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def sign[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def fmod_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def fmod[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def fmod_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def fmod[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def remainder_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def remainder[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal other: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def remainder_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def remainder[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def min_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def min[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def min[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def max_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def max[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def max[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def median[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def sort_out[T, TT <: TensorType](@ByRef values: Tensor[T, TT], @ByRef indices: Tensor[Long, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) descending: Boolean): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def sort_out[T, TT <: TensorType](@ByRef values: Tensor[T, TT], @ByRef indices: Tensor[Long, TT], @Const @ByRef self: Tensor[T, TT]): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def sort[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) descending: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def sort[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def argsort[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) descending: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def argsort[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def topk_out[T, TT <: TensorType](@ByRef values: Tensor[T, TT], @ByRef indices: Tensor[Long, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) k: CLongPointer, @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) largest: Boolean, @Cast(Array("bool")) sorted: Boolean): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def topk_out[T, TT <: TensorType](@ByRef values: Tensor[T, TT], @ByRef indices: Tensor[Long, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) k: CLongPointer): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def topk[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) k: CLongPointer, @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) largest: Boolean, @Cast(Array("bool")) sorted: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def topk[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) k: CLongPointer): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def all[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def any[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def renorm_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal p: Scalar[T], @Cast(Array("int64_t")) dim: CLongPointer, @ByVal maxnorm: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def renorm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal p: Scalar[T], @Cast(Array("int64_t")) dim: CLongPointer, @ByVal maxnorm: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @Cast(Array("bool")) def equal[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef other: Tensor[T, TT]): Boolean
	@native @Namespace("at") @ByRef def pow_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef exponent: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def pow[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef exponent: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def pow_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByVal self: Scalar[T], @Const @ByRef exponent: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def pow[T, TT <: TensorType](@ByVal self: Scalar[T], @Const @ByRef exponent: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def normal_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef mean: Tensor[T, TT], std: Double, generator: Generator): Tensor[T, TT]
	@native @Namespace("at") @ByRef def normal_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef mean: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def normal[T, TT <: TensorType](@Const @ByRef mean: Tensor[T, TT], std: Double, generator: Generator): Tensor[T, TT]
	@native @Namespace("at") @ByVal def normal[T, TT <: TensorType](@Const @ByRef mean: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def normal_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], mean: Double, @Const @ByRef std: Tensor[T, TT], generator: Generator): Tensor[T, TT]
	@native @Namespace("at") @ByRef def normal_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], mean: Double, @Const @ByRef std: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def normal[T, TT <: TensorType](mean: Double, @Const @ByRef std: Tensor[T, TT], generator: Generator): Tensor[T, TT]
	@native @Namespace("at") @ByVal def normal[T, TT <: TensorType](mean: Double, @Const @ByRef std: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def normal_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef mean: Tensor[T, TT], @Const @ByRef std: Tensor[T, TT], generator: Generator): Tensor[T, TT]
	@native @Namespace("at") @ByRef def normal_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef mean: Tensor[T, TT], @Const @ByRef std: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def normal[T, TT <: TensorType](@Const @ByRef mean: Tensor[T, TT], @Const @ByRef std: Tensor[T, TT], generator: Generator): Tensor[T, TT]
	@native @Namespace("at") @ByVal def normal[T, TT <: TensorType](@Const @ByRef mean: Tensor[T, TT], @Const @ByRef std: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def normal[T, TT <: TensorType](mean: Double, std: Double, @ByVal size: IntArrayRef, generator: Generator, @Const @ByRef options: TensorOptions[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def normal(mean: Double, std: Double, @ByVal size: IntArrayRef): Tensor[Double, CPU]
	@native @Namespace("at") @ByRef def normal_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], mean: Double, std: Double, @ByVal size: IntArrayRef, generator: Generator): Tensor[T, TT]
	@native @Namespace("at") @ByRef def normal_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], mean: Double, std: Double, @ByVal size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def alias[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _addr[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef vec1: Tensor[T, TT], @Const @ByRef vec2: Tensor[T, TT], @ByVal beta: Scalar[T], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _addr[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef vec1: Tensor[T, TT], @Const @ByRef vec2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _addr_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @Const @ByRef vec1: Tensor[T, TT], @Const @ByRef vec2: Tensor[T, TT], @ByVal beta: Scalar[T], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _addr_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @Const @ByRef vec1: Tensor[T, TT], @Const @ByRef vec2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _addr_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef vec1: Tensor[T, TT], @Const @ByRef vec2: Tensor[T, TT], @ByVal beta: Scalar[T], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _addr_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef vec1: Tensor[T, TT], @Const @ByRef vec2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _index_copy_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Const @ByRef index: Tensor[Long, TT], @Const @ByRef source: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _cumsum[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _cumsum_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _cumprod[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _cumprod_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _var[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) unbiased: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _var[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _std[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("bool")) unbiased: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _std[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _addmm_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef mat1: Tensor[T, TT], @Const @ByRef mat2: Tensor[T, TT], @ByVal beta: Scalar[T], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _addmm_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef mat1: Tensor[T, TT], @Const @ByRef mat2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _addmm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef mat1: Tensor[T, TT], @Const @ByRef mat2: Tensor[T, TT], @ByVal beta: Scalar[T], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _addmm[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef mat1: Tensor[T, TT], @Const @ByRef mat2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _addmm_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @Const @ByRef mat1: Tensor[T, TT], @Const @ByRef mat2: Tensor[T, TT], @ByVal beta: Scalar[T], @ByVal alpha: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _addmm_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @Const @ByRef mat1: Tensor[T, TT], @Const @ByRef mat2: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _cat[T, TT <: TensorType](@ByVal tensors: TensorList[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _cat[T, TT <: TensorType](@ByVal tensors: TensorList[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _cat_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByVal tensors: TensorList[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def _cat_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByVal tensors: TensorList[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _mode[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) keepdim: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def _mode[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def _mode_out[T, TT <: TensorType](@ByRef values: Tensor[T, TT], @ByRef indices: Tensor[Long, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) keepdim: Boolean): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def _mode_out[T, TT <: TensorType](@ByRef values: Tensor[T, TT], @ByRef indices: Tensor[Long, TT], @Const @ByRef self: Tensor[T, TT]): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def _max[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) keepdim: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def _max[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def _max_out[T, TT <: TensorType](@ByRef max: Tensor[T, TT], @ByRef max_indices: Tensor[Long, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) keepdim: Boolean): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def _max_out[T, TT <: TensorType](@ByRef max: Tensor[T, TT], @ByRef max_indices: Tensor[Long, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def _min[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) keepdim: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def _min[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def _min_out[T, TT <: TensorType](@ByRef min: Tensor[T, TT], @ByRef min_indices: Tensor[Long, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer, @Cast(Array("bool")) keepdim: Boolean): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def _min_out[T, TT <: TensorType](@ByRef min: Tensor[T, TT], @ByRef min_indices: Tensor[Long, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByRef def binary_cross_entropy_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def binary_cross_entropy_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def binary_cross_entropy[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def binary_cross_entropy[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def binary_cross_entropy_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def binary_cross_entropy_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def binary_cross_entropy_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def binary_cross_entropy_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def mse_loss_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def mse_loss_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def mse_loss[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def mse_loss[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def mse_loss_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def mse_loss_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def l1_loss_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def l1_loss_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def l1_loss[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def l1_loss[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def l1_loss_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def l1_loss_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def multi_margin_loss_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @ByVal p: Scalar[T], @ByVal margin: Scalar[T], @Const @ByRef weight: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def multi_margin_loss_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def multi_margin_loss[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @ByVal p: Scalar[T], @ByVal margin: Scalar[T], @Const @ByRef weight: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def multi_margin_loss[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def multi_margin_loss_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @ByVal p: Scalar[T], @ByVal margin: Scalar[T], @Const @ByRef weight: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def multi_margin_loss_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @ByVal p: Scalar[T], @ByVal margin: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def multi_margin_loss_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @ByVal p: Scalar[T], @ByVal margin: Scalar[T], @Const @ByRef weight: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def multi_margin_loss_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @ByVal p: Scalar[T], @ByVal margin: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def multilabel_margin_loss_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def multilabel_margin_loss_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def multilabel_margin_loss[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def multilabel_margin_loss[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def multilabel_margin_loss_forward_out[T, TT <: TensorType](@ByRef output: Tensor[T, TT], @ByRef is_target: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def multilabel_margin_loss_forward[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByRef def multilabel_margin_loss_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer, @Const @ByRef is_target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def multilabel_margin_loss_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer, @Const @ByRef is_target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def nll_loss_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer, @Cast(Array("int64_t")) ignore_index: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def nll_loss_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def nll_loss[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer, @Cast(Array("int64_t")) ignore_index: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def nll_loss[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def nll_loss_forward_out[T, TT <: TensorType](@ByRef output: Tensor[T, TT], @ByRef total_weight: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer, @Cast(Array("int64_t")) ignore_index: CLongPointer): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def nll_loss_forward[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer, @Cast(Array("int64_t")) ignore_index: CLongPointer): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByRef def nll_loss_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer, @Cast(Array("int64_t")) ignore_index: CLongPointer, @Const @ByRef total_weight: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def nll_loss_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer, @Cast(Array("int64_t")) ignore_index: CLongPointer, @Const @ByRef total_weight: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def nll_loss2d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer, @Cast(Array("int64_t")) ignore_index: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def nll_loss2d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def nll_loss2d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer, @Cast(Array("int64_t")) ignore_index: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def nll_loss2d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def nll_loss2d_forward_out[T, TT <: TensorType](@ByRef output: Tensor[T, TT], @ByRef total_weight: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer, @Cast(Array("int64_t")) ignore_index: CLongPointer): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def nll_loss2d_forward[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer, @Cast(Array("int64_t")) ignore_index: CLongPointer): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByRef def nll_loss2d_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer, @Cast(Array("int64_t")) ignore_index: CLongPointer, @Const @ByRef total_weight: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def nll_loss2d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer, @Cast(Array("int64_t")) ignore_index: CLongPointer, @Const @ByRef total_weight: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def smooth_l1_loss_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def smooth_l1_loss_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def smooth_l1_loss[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def smooth_l1_loss[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def smooth_l1_loss_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def smooth_l1_loss_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def soft_margin_loss_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def soft_margin_loss_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def soft_margin_loss[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def soft_margin_loss[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def soft_margin_loss_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def soft_margin_loss_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef target: Tensor[T, TT], @Cast(Array("int64_t")) reduction: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def elu_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal alpha: Scalar[T], @ByVal scale: Scalar[T], @ByVal input_scale: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def elu_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def elu[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal alpha: Scalar[T], @ByVal scale: Scalar[T], @ByVal input_scale: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def elu[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def elu_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @ByVal alpha: Scalar[T], @ByVal scale: Scalar[T], @ByVal input_scale: Scalar[T], @Const @ByRef output: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def elu_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @ByVal alpha: Scalar[T], @ByVal scale: Scalar[T], @ByVal input_scale: Scalar[T], @Const @ByRef output: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def elu_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @ByVal alpha: Scalar[T], @ByVal scale: Scalar[T], @ByVal input_scale: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def elu_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def glu_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def glu_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def glu[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def glu[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def glu_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByVal def glu_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Cast(Array("int64_t")) dim: CLongPointer): Tensor[T, TT]
	@native @Namespace("at") @ByRef def hardtanh_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal min_val: Scalar[T], @ByVal max_val: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def hardtanh_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def hardtanh[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal min_val: Scalar[T], @ByVal max_val: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def hardtanh[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def hardtanh_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal min_val: Scalar[T], @ByVal max_val: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def hardtanh_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal min_val: Scalar[T], @ByVal max_val: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def hardtanh_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @ByVal min_val: Scalar[T], @ByVal max_val: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def hardtanh_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def leaky_relu_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal negative_slope: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def leaky_relu_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def leaky_relu[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal negative_slope: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def leaky_relu[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def leaky_relu_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal negative_slope: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def leaky_relu_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal negative_slope: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def leaky_relu_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @ByVal negative_slope: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def leaky_relu_[T, TT <: TensorType](@ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def log_sigmoid_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def log_sigmoid[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def log_sigmoid_forward_out[T, TT <: TensorType](@ByRef output: Tensor[T, TT], @ByRef buffer: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def log_sigmoid_forward[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByRef def log_sigmoid_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef buffer: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def log_sigmoid_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef buffer: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def rrelu_with_noise_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef noise: Tensor[T, TT], @ByVal lower: Scalar[T], @ByVal upper: Scalar[T], @Cast(Array("bool")) training: Boolean, generator: Generator): Tensor[T, TT]
	@native @Namespace("at") @ByRef def rrelu_with_noise_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef noise: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def rrelu_with_noise[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef noise: Tensor[T, TT], @ByVal lower: Scalar[T], @ByVal upper: Scalar[T], @Cast(Array("bool")) training: Boolean, generator: Generator): Tensor[T, TT]
	@native @Namespace("at") @ByVal def rrelu_with_noise[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef noise: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def rrelu_with_noise_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef noise: Tensor[T, TT], @ByVal lower: Scalar[T], @ByVal upper: Scalar[T], @Cast(Array("bool")) training: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def rrelu_with_noise_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef noise: Tensor[T, TT], @ByVal lower: Scalar[T], @ByVal upper: Scalar[T], @Cast(Array("bool")) training: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def rrelu_with_noise_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @Const @ByRef noise: Tensor[T, TT], @ByVal lower: Scalar[T], @ByVal upper: Scalar[T], @Cast(Array("bool")) training: Boolean, generator: Generator): Tensor[T, TT]
	@native @Namespace("at") @ByRef def rrelu_with_noise_[T, TT <: TensorType](@ByRef self: Tensor[T, TT], @Const @ByRef noise: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def softplus_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal beta: Scalar[T], @ByVal threshold: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def softplus_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def softplus[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal beta: Scalar[T], @ByVal threshold: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def softplus[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def softplus_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal beta: Scalar[T], @ByVal threshold: Scalar[T], @Const @ByRef output: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def softplus_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal beta: Scalar[T], @ByVal threshold: Scalar[T], @Const @ByRef output: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def softshrink_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal lambd: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def softshrink_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def softshrink[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal lambd: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def softshrink[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def softshrink_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal lambd: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def softshrink_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal lambd: Scalar[T]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def adaptive_avg_pool2d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal output_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def adaptive_avg_pool2d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal output_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def mkldnn_adaptive_avg_pool2d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal output_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _adaptive_avg_pool2d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal output_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def _adaptive_avg_pool2d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def adaptive_avg_pool3d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal output_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def adaptive_avg_pool3d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal output_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def adaptive_avg_pool3d_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def adaptive_avg_pool3d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def adaptive_max_pool2d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByRef indices: Tensor[Long, TT], @Const @ByRef self: Tensor[T, TT], @ByVal output_size: IntArrayRef): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def adaptive_max_pool2d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal output_size: IntArrayRef): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByRef def adaptive_max_pool2d_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef indices: Tensor[Long, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def adaptive_max_pool2d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef indices: Tensor[Long, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def adaptive_max_pool3d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByRef indices: Tensor[Long, TT], @Const @ByRef self: Tensor[T, TT], @ByVal output_size: IntArrayRef): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def adaptive_max_pool3d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal output_size: IntArrayRef): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByRef def adaptive_max_pool3d_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef indices: Tensor[Long, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def adaptive_max_pool3d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef indices: Tensor[Long, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def avg_pool2d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @Cast(Array("bool")) ceil_mode: Boolean, @Cast(Array("bool")) count_include_pad: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def avg_pool2d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def avg_pool2d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @Cast(Array("bool")) ceil_mode: Boolean, @Cast(Array("bool")) count_include_pad: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def avg_pool2d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def avg_pool2d_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @Cast(Array("bool")) ceil_mode: Boolean, @Cast(Array("bool")) count_include_pad: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def avg_pool2d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @Cast(Array("bool")) ceil_mode: Boolean, @Cast(Array("bool")) count_include_pad: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def avg_pool3d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @Cast(Array("bool")) ceil_mode: Boolean, @Cast(Array("bool")) count_include_pad: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def avg_pool3d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def avg_pool3d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @Cast(Array("bool")) ceil_mode: Boolean, @Cast(Array("bool")) count_include_pad: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def avg_pool3d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def avg_pool3d_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @Cast(Array("bool")) ceil_mode: Boolean, @Cast(Array("bool")) count_include_pad: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def avg_pool3d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @Cast(Array("bool")) ceil_mode: Boolean, @Cast(Array("bool")) count_include_pad: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def fractional_max_pool2d_out[T, TT <: TensorType](@ByRef output: Tensor[T, TT], @ByRef indices: Tensor[Long, TT], @Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal output_size: IntArrayRef, @Const @ByRef random_samples: Tensor[T, TT]): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def fractional_max_pool2d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal output_size: IntArrayRef, @Const @ByRef random_samples: Tensor[T, TT]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByRef def fractional_max_pool2d_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal output_size: IntArrayRef, @Const @ByRef indices: Tensor[Long, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def fractional_max_pool2d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal output_size: IntArrayRef, @Const @ByRef indices: Tensor[Long, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def fractional_max_pool3d_out[T, TT <: TensorType](@ByRef output: Tensor[T, TT], @ByRef indices: Tensor[Long, TT], @Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal output_size: IntArrayRef, @Const @ByRef random_samples: Tensor[T, TT]): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def fractional_max_pool3d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal output_size: IntArrayRef, @Const @ByRef random_samples: Tensor[T, TT]): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByRef def fractional_max_pool3d_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal output_size: IntArrayRef, @Const @ByRef indices: Tensor[Long, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def fractional_max_pool3d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal output_size: IntArrayRef, @Const @ByRef indices: Tensor[Long, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def max_pool2d_with_indices_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByRef indices: Tensor[Long, TT], @Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("bool")) ceil_mode: Boolean): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def max_pool2d_with_indices_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByRef indices: Tensor[Long, TT], @Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def max_pool2d_with_indices[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("bool")) ceil_mode: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def max_pool2d_with_indices[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByRef def max_pool2d_with_indices_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("bool")) ceil_mode: Boolean, @Const @ByRef indices: Tensor[Long, TT]): Tensor[Long, TT]
	@native @Namespace("at") @ByVal def max_pool2d_with_indices_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("bool")) ceil_mode: Boolean, @Const @ByRef indices: Tensor[Long, TT]): Tensor[Long, TT]
	@native @Namespace("at") @ByVal def max_pool3d_with_indices_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByRef indices: Tensor[Long, TT], @Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("bool")) ceil_mode: Boolean): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def max_pool3d_with_indices_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @ByRef indices: Tensor[Long, TT], @Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def max_pool3d_with_indices[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("bool")) ceil_mode: Boolean): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByVal def max_pool3d_with_indices[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByRef def max_pool3d_with_indices_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("bool")) ceil_mode: Boolean, @Const @ByRef indices: Tensor[Long, TT]): Tensor[Long, TT]
	@native @Namespace("at") @ByVal def max_pool3d_with_indices_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef, @Cast(Array("bool")) ceil_mode: Boolean, @Const @ByRef indices: Tensor[Long, TT]): Tensor[Long, TT]
	@native @Namespace("at") @ByRef def max_unpool2d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef indices: Tensor[Long, TT], @ByVal output_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def max_unpool2d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef indices: Tensor[Long, TT], @ByVal output_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def max_unpool2d_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef indices: Tensor[Long, TT], @ByVal output_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def max_unpool2d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef indices: Tensor[Long, TT], @ByVal output_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def max_unpool3d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef indices: Tensor[Long, TT], @ByVal output_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def max_unpool3d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef indices: Tensor[Long, TT], @ByVal output_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def max_unpool3d_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef indices: Tensor[Long, TT], @ByVal output_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def max_unpool3d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef indices: Tensor[Long, TT], @ByVal output_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def reflection_pad1d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def reflection_pad1d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def reflection_pad1d_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def reflection_pad1d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def reflection_pad2d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def reflection_pad2d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def reflection_pad2d_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def reflection_pad2d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def replication_pad1d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def replication_pad1d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def replication_pad1d_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def replication_pad1d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def replication_pad2d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def replication_pad2d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def replication_pad2d_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def replication_pad2d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def replication_pad3d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def replication_pad3d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def replication_pad3d_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def replication_pad3d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def upsample_linear1d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal output_size: IntArrayRef, @Cast(Array("bool")) align_corners: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def upsample_linear1d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal output_size: IntArrayRef, @Cast(Array("bool")) align_corners: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def upsample_linear1d_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @ByVal output_size: IntArrayRef, @ByVal input_size: IntArrayRef, @Cast(Array("bool")) align_corners: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def upsample_linear1d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @ByVal output_size: IntArrayRef, @ByVal input_size: IntArrayRef, @Cast(Array("bool")) align_corners: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def upsample_bilinear2d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal output_size: IntArrayRef, @Cast(Array("bool")) align_corners: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def upsample_bilinear2d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal output_size: IntArrayRef, @Cast(Array("bool")) align_corners: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def upsample_bilinear2d_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @ByVal output_size: IntArrayRef, @ByVal input_size: IntArrayRef, @Cast(Array("bool")) align_corners: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def upsample_bilinear2d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @ByVal output_size: IntArrayRef, @ByVal input_size: IntArrayRef, @Cast(Array("bool")) align_corners: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def upsample_bicubic2d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal output_size: IntArrayRef, @Cast(Array("bool")) align_corners: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def upsample_bicubic2d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal output_size: IntArrayRef, @Cast(Array("bool")) align_corners: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def upsample_bicubic2d_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @ByVal output_size: IntArrayRef, @ByVal input_size: IntArrayRef, @Cast(Array("bool")) align_corners: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def upsample_bicubic2d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @ByVal output_size: IntArrayRef, @ByVal input_size: IntArrayRef, @Cast(Array("bool")) align_corners: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def upsample_trilinear3d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal output_size: IntArrayRef, @Cast(Array("bool")) align_corners: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def upsample_trilinear3d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal output_size: IntArrayRef, @Cast(Array("bool")) align_corners: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def upsample_trilinear3d_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @ByVal output_size: IntArrayRef, @ByVal input_size: IntArrayRef, @Cast(Array("bool")) align_corners: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByVal def upsample_trilinear3d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @ByVal output_size: IntArrayRef, @ByVal input_size: IntArrayRef, @Cast(Array("bool")) align_corners: Boolean): Tensor[T, TT]
	@native @Namespace("at") @ByRef def upsample_nearest1d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal output_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def upsample_nearest1d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal output_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def upsample_nearest1d_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @ByVal output_size: IntArrayRef, @ByVal input_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def upsample_nearest1d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @ByVal output_size: IntArrayRef, @ByVal input_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def upsample_nearest2d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal output_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def upsample_nearest2d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal output_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def upsample_nearest2d_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @ByVal output_size: IntArrayRef, @ByVal input_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def upsample_nearest2d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @ByVal output_size: IntArrayRef, @ByVal input_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def upsample_nearest3d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal output_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def upsample_nearest3d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal output_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def upsample_nearest3d_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @ByVal output_size: IntArrayRef, @ByVal input_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def upsample_nearest3d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @ByVal output_size: IntArrayRef, @ByVal input_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def sigmoid_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef output: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def sigmoid_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef output: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def tanh_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef output: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByVal def tanh_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef output: Tensor[T, TT]): Tensor[T, TT]
	@native @Namespace("at") @ByRef def conv_transpose2d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @Const @ByRef bias: Tensor[T, TT], @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal output_padding: IntArrayRef, @ByVal dilation: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def conv_transpose2d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def conv_transpose2d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @Const @ByRef bias: Tensor[T, TT], @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal output_padding: IntArrayRef, @ByVal dilation: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def conv_transpose2d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def conv_transpose2d_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @ByRef grad_weight: Tensor[T, TT], @ByRef grad_bias: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal output_padding: IntArrayRef, @ByVal dilation: IntArrayRef, @Const @ByRef columns: Tensor[T, TT], @Const @ByRef ones: Tensor[T, TT]): TensorRefTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def conv_transpose2d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal output_padding: IntArrayRef, @ByVal dilation: IntArrayRef, @Const @ByRef columns: Tensor[T, TT], @Const @ByRef ones: Tensor[T, TT], @ByVal output_mask: ArrayBool3): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByRef def conv_transpose3d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @Const @ByRef bias: Tensor[T, TT], @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal output_padding: IntArrayRef, @ByVal dilation: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def conv_transpose3d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def conv_transpose3d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @Const @ByRef bias: Tensor[T, TT], @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal output_padding: IntArrayRef, @ByVal dilation: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def conv_transpose3d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def conv_transpose3d_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @ByRef grad_weight: Tensor[T, TT], @ByRef grad_bias: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal output_padding: IntArrayRef, @ByVal dilation: IntArrayRef, @Const @ByRef finput: Tensor[T, TT], @Const @ByRef fgrad_input: Tensor[T, TT]): TensorRefTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def conv_transpose3d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal output_padding: IntArrayRef, @ByVal dilation: IntArrayRef, @Const @ByRef finput: Tensor[T, TT], @Const @ByRef fgrad_input: Tensor[T, TT], @ByVal output_mask: ArrayBool3): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByRef def thnn_conv2d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @Const @ByRef bias: Tensor[T, TT], @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def thnn_conv2d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def thnn_conv2d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @Const @ByRef bias: Tensor[T, TT], @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def thnn_conv2d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def thnn_conv2d_forward_out[T, TT <: TensorType](@ByRef output: Tensor[T, TT], @ByRef finput: Tensor[T, TT], @ByRef fgrad_input: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @Const @ByRef bias: Tensor[T, TT], @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef): TensorRefTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def thnn_conv2d_forward[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @Const @ByRef bias: Tensor[T, TT], @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def thnn_conv2d_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @ByRef grad_weight: Tensor[T, TT], @ByRef grad_bias: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @Const @ByRef finput: Tensor[T, TT], @Const @ByRef fgrad_input: Tensor[T, TT]): TensorRefTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def thnn_conv2d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @Const @ByRef finput: Tensor[T, TT], @Const @ByRef fgrad_input: Tensor[T, TT], @ByVal output_mask: ArrayBool3): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByRef def thnn_conv_depthwise2d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @Const @ByRef bias: Tensor[T, TT], @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def thnn_conv_depthwise2d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def thnn_conv_depthwise2d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @Const @ByRef bias: Tensor[T, TT], @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def thnn_conv_depthwise2d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def thnn_conv_depthwise2d_forward_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @Const @ByRef bias: Tensor[T, TT], @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def thnn_conv_depthwise2d_forward[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @Const @ByRef bias: Tensor[T, TT], @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def thnn_conv_depthwise2d_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @ByRef grad_weight: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef): TensorRefTuple[T,T,TT]
	@native @Namespace("at") @ByVal def thnn_conv_depthwise2d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef, @ByVal output_mask: ArrayBool2): TensorTuple[T,T,TT]
	@native @Namespace("at") @ByRef def thnn_conv3d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @Const @ByRef bias: Tensor[T, TT], @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def thnn_conv3d_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def thnn_conv3d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @Const @ByRef bias: Tensor[T, TT], @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def thnn_conv3d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def thnn_conv3d_forward_out[T, TT <: TensorType](@ByRef output: Tensor[T, TT], @ByRef finput: Tensor[T, TT], @ByRef fgrad_input: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @Const @ByRef bias: Tensor[T, TT], @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef): TensorRefTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def thnn_conv3d_forward[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @Const @ByRef bias: Tensor[T, TT], @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def thnn_conv3d_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @ByRef grad_weight: Tensor[T, TT], @ByRef grad_bias: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @Const @ByRef finput: Tensor[T, TT], @Const @ByRef fgrad_input: Tensor[T, TT]): TensorRefTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def thnn_conv3d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @Const @ByRef finput: Tensor[T, TT], @Const @ByRef fgrad_input: Tensor[T, TT], @ByVal output_mask: ArrayBool3): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def conv_dilated2d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @Const @ByRef bias: Tensor[T, TT], @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def conv_dilated2d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def conv_dilated2d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef, @ByVal output_mask: ArrayBool3): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByVal def conv_dilated3d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @Const @ByRef bias: Tensor[T, TT], @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def conv_dilated3d[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def conv_dilated3d_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @Const @ByRef weight: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal stride: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal dilation: IntArrayRef, @ByVal output_mask: ArrayBool3): TensorTriple[T,T,T,TT]
	@native @Namespace("at") @ByRef def col2im_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal output_size: IntArrayRef, @ByVal kernel_size: IntArrayRef, @ByVal dilation: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def col2im[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal output_size: IntArrayRef, @ByVal kernel_size: IntArrayRef, @ByVal dilation: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def col2im_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal dilation: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def col2im_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal dilation: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def im2col_out[T, TT <: TensorType](@ByRef out: Tensor[T, TT], @Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal dilation: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def im2col[T, TT <: TensorType](@Const @ByRef self: Tensor[T, TT], @ByVal kernel_size: IntArrayRef, @ByVal dilation: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByRef def im2col_backward_out[T, TT <: TensorType](@ByRef grad_input: Tensor[T, TT], @Const @ByRef grad_output: Tensor[T, TT], @ByVal input_size: IntArrayRef, @ByVal kernel_size: IntArrayRef, @ByVal dilation: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at") @ByVal def im2col_backward[T, TT <: TensorType](@Const @ByRef grad_output: Tensor[T, TT], @ByVal input_size: IntArrayRef, @ByVal kernel_size: IntArrayRef, @ByVal dilation: IntArrayRef, @ByVal padding: IntArrayRef, @ByVal stride: IntArrayRef): Tensor[T, TT]
	@native @Namespace("at::detail") @ByVal def infer_backend[T, TT <: TensorType](@Const @ByRef t: Tensor[T, TT]): Backend
	@native @Namespace("at::detail") @Cast(Array("bool")) def infer_is_variable[T, TT <: TensorType](@Const @ByRef t: Tensor[T, TT]): Boolean

}
